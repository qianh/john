{"meta":{"title":"John","subtitle":"个人博客","description":"个人博客，活到老学到老","author":"John","url":"https://qianh.github.io","root":"/"},"pages":[],"posts":[{"title":"java源代码赏析 —— 迭代器（Iterator）","slug":"java-iterator","date":"2018-05-14T13:25:54.000Z","updated":"2019-06-21T06:05:19.722Z","comments":true,"path":"2018/05/14/java-iterator/","link":"","permalink":"https://qianh.github.io/2018/05/14/java-iterator/","excerpt":"","text":"(1) java集合类都在java.util包下，都可以追溯到一个接口——iterator(迭代器)。iterator是对原java Enumeration的替代。下图展示了java集合家族的关系： (2) iterator 接口方法：12345678910111213141516public interface Iterator&lt;E&gt; &#123; //如果迭代器中还有元素，则返回true boolean hasNext(); //返回迭代器中的下一个元素 E next(); //删除迭代器新返回的元素 default void remove() &#123; throw new UnsupportedOperationException(\"remove\"); &#125; //为每个剩余元素执行给定的操作,直到所有的元素都已经被处理或行动将抛出一个异常 default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 对于 hasNext(),next(),remove(),用List来实际操作一下用法：12345678910111213141516171819public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); Iterator i = l.iterator(); while (i.hasNext()) &#123; System.out.println(i.next()); i.remove(); &#125; System.out.println(\"list size:\"+list.size());&#125;/** 输出结果：* a* b* c* list size:0*/ (3) 与之相近的 iterable (java.lang包下)Collection实现了iterable接口， iterable接口提供方法：123456789101112public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; iterable 提供了获取Iterator的方法，可以获得Iterator迭代器的相应功能。(4) Iterator和Iterable 区别：4.1 所属包不同，Iterator在java.util包下，Iterable在java.lang包下4.2 Iterator是迭代器类，而Iterable是接口。4.3 Iterator接口的核心方法next()或者hasNext() 是依赖于迭代器的当前迭代位置的。 如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。 除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 但即时这样，Collection也只能同时存在一个当前迭代位置。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。 多个迭代器是互不干扰的。","categories":[{"name":"java","slug":"java","permalink":"https://qianh.github.io/categories/java/"}],"tags":[{"name":"java 源码","slug":"java-源码","permalink":"https://qianh.github.io/tags/java-源码/"}]},{"title":"spring-aop","slug":"spring-aop","date":"2018-05-08T06:16:51.000Z","updated":"2019-06-21T06:05:19.725Z","comments":true,"path":"2018/05/08/spring-aop/","link":"","permalink":"https://qianh.github.io/2018/05/08/spring-aop/","excerpt":"","text":"1.背景 分布于应用中多处的功能被称为横切关注点（cross-cutting concerns）。通常，这些横切关注点从概念上是于应用的业务逻辑相分离的（但是往往直接潜入到应用的业务逻辑之中）。将这些横切关注点于业务逻辑相分离正是面向切面编程（AOP）所要解决的。——《Spring实战》 2.什么是面向切面编程 继承与委托是最常见的实现重用通用功能的面向对象技术。但是我们不太会在应用中使用相同的基类，而使用委托需要对委托对象进行复杂的调用。 切面提供了取代继承和委托的另一种选择，在很多场景下更清晰简洁。横切关注点可以被模块化为特殊的类，这些类被称为切面。 这样做有两个好处： 每个关注点现在只集中于一处，而不是分散于多处代码中； 服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。 3.AOP术语 与大多数技术一样，AOP已经形成了自己的术语。描述切面的常用术语有通知（advice）、切点（pointcut）和连接点（join point） 3.1 通知（advice）在AOP术语中，切面的工作被称为通知。Spring切面可以应用5种类型的通知： Before——在方法被调用之前调用通知。 After——在方法完成之后调用通知，无论方法执行是否成功。 After-returning——在方法成功执行之后调用通知。 After-throwing——在方法抛出异常后调用通知。 Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 3.2 连接点（Joinpoint） 我们的应用程序可能需要对数以千计的时机应用通知，这些时机被称为连接点。 连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。 3.3 切点（Pointcut） 一个切面并不需要通知应用中所有的连接点，切点有助于缩小切面所通知的连接点的范围。 切点的定义会匹配通知所有要织入的一个或多个连接点。 通常使用明确的类和方法名称来指定这些切点，或是利用正则表达式定义匹配的类和方法名称模式来指定这些切点。 3.4 切面（Aspect） 切面是通知和切点的结合。 通知和切点共同定义了关于切面的全部内容——它是什么，在何时完成其功能。 3.5 引入（Introduction）引入允许我们向现有的类添加新的方法或属性 3.6 织入（Weaving）织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入： 编译期——切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。 类加载期——切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入之前增强该目标类的字节码。AspectJ 5的LTW就支持以这种方式织入切面。 运行期——切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器回会目标对象动态创建一个代理对象。Spring AOP就是以这种方式织入切面的。 4.Spring AOP4.1 Spring 提供了4种各具特色的AOP支持： 基于代理的经典AOP； @AspectJ 注解驱动的切面； 纯POJO切面； 注入式AspectJ切面（适合Spring各版本） Spring 对AOP的支持局限于方法拦截，且只支持方法连接点（不支持字段和构造器接入点）。4.2 使用切点选择连接点 execution指示器是编写切点定义时最主要使用的指示器。 execution()编写规则如：execution( xxx.xxx.xxx.impl...*(..)) 4.3 在XML中声明切面Spring的AOP配置元素简化了基于POJO切面的声明：1234567891011&lt;aop:advisor&gt; &lt;!-- 定义AOP通知器 --&gt;&lt;aop:after&gt; &lt;!-- 定义AOP后置通知（不管被通知的方法是否执行成功） --&gt;&lt;aop:after-returning&gt; &lt;!-- 定义AOP after-returning 通知 --&gt;&lt;aop:after-throwing&gt; &lt;!-- 定义AOP after-throwing 通知 --&gt;&lt;aop:around&gt; &lt;!-- 定义AOP 环绕通知 --&gt;&lt;aop:aspect&gt; &lt;!-- 定义切面 --&gt;&lt;aop:aspectj-antoproxy&gt; &lt;!-- 启用@AspectJ 注解驱动的切面 --&gt;&lt;aop:before&gt; &lt;!-- 定义AOP 前置通知 --&gt;&lt;aop:config&gt; &lt;!-- 顶层的AOP配置元素。大多数的&lt;aop:*&gt;元素必须包含在&lt;aop:config&gt;元素内 --&gt;&lt;aop:declare&gt; &lt;!-- 为被通知的对象引入额外的接口，并透明地实现 --&gt;&lt;aop:pointcut&gt; &lt;!-- 定义切点 --&gt; 4.4 使用例子123456789&lt;bean id=\"xxxHandler\" class=\"xxx.BusinessExceptionAop\"&gt; &lt;property name=\"brave\" value=\"#&#123;brave&#125;\" /&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect ref=\"xxxHandler\"&gt; &lt;aop:pointcut id=\"exceptionService\" expression=\"execution(* xxx.impl..*.*(..))\" /&gt; &lt;aop:after-throwing pointcut-ref=\"exceptionService\" method=\"afterThrowing\" throwing=\"e\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://qianh.github.io/categories/Spring/"}],"tags":[{"name":"Spring aop","slug":"Spring-aop","permalink":"https://qianh.github.io/tags/Spring-aop/"}]},{"title":"spring-ioc","slug":"spring-ioc","date":"2018-05-07T06:16:26.000Z","updated":"2019-06-21T06:05:19.726Z","comments":true,"path":"2018/05/07/spring-ioc/","link":"","permalink":"https://qianh.github.io/2018/05/07/spring-ioc/","excerpt":"","text":"参考：关于spring ioc（1）IOC(Inversion of Control) IOC，另外一种说法叫DI（Dependency Injection），即依赖注入。它并不是一种技术实现，而是一种设计思想。在任何一个有实际开发意义的程序项目中，我们会使用很多类来描述它们特有的功能，并且通过类与类之间的相互协作来完成特定的业务逻辑。这个时候，每个类都需要负责管理与自己有交互的类的引用和依赖，代码将会变的异常难以维护和极度的高耦合。而IOC的出现正是用来解决这个问题，我们通过IOC将这些相互依赖对象的创建、协调工作交给Spring容器去处理，每个对象只需要关注其自身的业务逻辑关系就可以了。在这样的角度上来看，获得依赖的对象的方式，进行了反转，变成了由spring容器控制对象如何获取外部资源（包括其他对象和文件资料等等）。 Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 总结：ioc 最主要的是改变了以往的编程思想，由原先通过 new 的方式获取依赖对象的方式（正转），变成了由spring容器来进行实例化（反转），应用程序由主动变成了被动接受。（2）具体使用（自动装配与注解注入） Spring的自动装配有三种模式：byType(根据类型)，byName(根据名称)、constructor(根据构造函数)。 2.1 byType在byTpye模式中，Spring容器会基于反射查看bean定义的类，然后找到与依赖类型相同的bean注入到另外的bean中，这个过程需要借助setter注入来完成，因此必须存在set方法，否则注入失败。 123456789101112131415161718192021222324//dao层public class UserDaoImpl implements UserDao&#123; //....... @Override public void doSomething()&#123; System.out.println(\"UserDaoImpl doSomething ...\"); &#125;&#125;//service层public class UserServiceImpl implements UserService &#123; //需要注入的依赖 private UserDao userDao; /** * set方法 */ public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void doSomething()&#123; userDao.doSomething(); &#125;&#125; 基于xml的配置如下，通过使用＜bean＞中的autowire属性为”byType”，按类型自动装配 userService123&lt;bean id=\"userDao\" class=\"xxx.dao.impl.UserDaoImpl\" /&gt;&lt;!-- byType 根据类型自动装配userDao--&gt;&lt;bean id=\"userService\" autowire=\"byType\" class=\"xxx.service.impl.UserServiceImpl\" /&gt; byType模式可能存一种注入失败的情况：由于是基于类型的注入，因此当xml文件中存在多个相同类型名称不同的实例Bean时，Spring容器依赖注入仍然会失败，因为存在多种适合的选项，Spring容器无法知道该注入那种。恰好spring为我们提供了解决方案（指定注入需要的Bean实例）：通过设置＜bean＞标签的autowire-candidate为false，来过滤那些不需要注入的实例Bean123&lt;bean id=\"userDao\" class=\"xxx.dao.impl.UserDaoImpl\" /&gt;&lt;!-- autowire-candidate=\"false\" 过滤该类型 --&gt;&lt;bean id=\"userDao2\" autowire-candidate=\"false\" class=\"xxx.dao.impl.UserDaoImpl\" /&gt; 2.2 byName(实际项目中用得比较多)byName模式的自动装配：Spring只会尝试将属性名与bean名称进行匹配，如果找到则注入依赖bean。1234&lt;bean id=\"userDao\" class=\"xxx.dao.impl.UserDaoImpl\" /&gt;&lt;bean id=\"userDao2\" class=\"xxx.dao.impl.UserDaoImpl\" /&gt;&lt;!-- byName 根据名称自动装配，找到UserServiceImpl名为 userDao属性并注入--&gt;&lt;bean id=\"userService\" autowire=\"byName\" class=\"xxx.service.impl.UserServiceImpl\" /&gt; 基于注解的自动装配(@Autowired&amp;@Resource&amp;@Value)1) @Autowired 上述的用法可以用在bean数量很少的情况下，如果数量过多，都需要手动配置xml的话，显然不太优雅，也不利于维护 好在Spring 2.5 中引入了 @Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用标注到成员变量时不需要有set方法，@Autowired 默认按类型匹配的 在xml配置文件中加入以下配置信息：1&lt;context:annotation-config /&gt; 12345678910public class UserServiceImpl implements UserService &#123; //标注成员变量 @Autowired private UserDao userDao; @Override public void doSomething()&#123; userDao.doSomething(); &#125;&#125; 在@Autowired中还传递了一个required=false的属性，false指明当userDao实例存在就注入不存在就忽略；如果为true，就必须注入，若userDao实例不存在，就抛出异常。由于@Autowired默认情况下是按类型匹配的(byType)，如果想要按名称(byName)匹配的话，可以使用@Qualifier注解与@Autowired结合：123456public class UserServiceImpl implements UserService &#123; //标注成员变量 @Autowired @Qualifier(\"userDao1\") private UserDao userDao; &#125; 2) @Resource@Autowried具备相同功效，但是默认按 byName模式 自动注入,依赖包是 javax.annotation.Resource 可以标注在成员变量和set方法上，但无法标注构造函数。@Resource有两个中重要的属性：name和type。Spring容器对于@Resource注解的name属性解析为bean的名字，type属性则解析为bean的类型。若设置name属性，则按byName模式的自动注入，若设置type属性则按 byType模式自动注入。如果都不指定，Spring容器将通过反射技术默认按byName模式注入。12345678910111213//@Autowired标注成员变量@Autowired@Qualifier(\"userDao\")private UserDao userDao; //上述代码等价于@Resource@Resource(name=\"userDao\")private UserDao userDao;//用于成员变量//也可以用于set方法标注@Resource(name=\"userDao\")public void setUserDao(UserDao userDao) &#123; this.userDao= userDao;&#125; 3) @Value以上两种自动装配的依赖注入并不适合简单值类型，如int、boolean、long、String以及Enum等，对于这些类型，Spring容器提供了@Value注入的方式：1234567891011121314public class UserServiceImpl implements UserService &#123; //标注成员变量 @Autowired @Qualifier(\"userDao\") private UserDao userDao; //占位符方式 @Value(\"$&#123;jdbc.address&#125;\") private String address; //SpEL表达方式，其中代表xml配置文件中的id值configProperties @Value(\"#&#123;configProperties['jdbc.username']&#125;\") private String userName; ...&#125; （3）IOC管理 bean3.1 Bean的命名每一个交给Spring IOC容器创建的对象必须被分配至少一个名称，如果开发者没有提供，Spring容器将会为其分配一个内部名称，通过Bean的名称，我们可以在其他类中查找该类并使用它，如前面的案例，也是通过Bean名称获取到实际对象并执行对应的操作。在基于xml的配置信息中，可以使用id属性来为一个Bean分配名称，在同一个xml配置文件中，id必须是唯一的，但不同的xml可以相同，当然还可以使用name来为Bean分配名称，name属性可以分配多个名称，此时可使用空格、逗号、分号来分离给定Bean分配多个名称，而id属性则无法这样使用。1234&lt;!-- name属性配置多个名称 --&gt;&lt;bean name=\"userDao,userDao1\" class=\"xxx.dao.impl.UserDaoImpl\"/&gt;&lt;!-- id属性配置唯一名称而且不能与name相同--&gt;&lt;bean id=\"userDao2\" class=\"xxx.dao.impl.UserDaoImpl\"/&gt; 上述的Bean对象声明使用都在xml内声明手动声明的方式，一旦Bean对象多起来，管理Bean就会变得复杂。因此Spring提供了基于Java注解的配置方式，分别使用org.springframework.stereotype.Service（@Service）和org.springframework.stereotype.Repository（@Repository）声明XxxServiceImpl和XxxDaoImpl类，使用@Autowired注解注入xxxDao（需要在xml声明注解驱动），或者使用（@Component）。 Spring的框架中提供了与@Component注解等效的三个注解，@Repository 用于对DAO实现类进行标注，@Service 用于对Service实现类进行标注，@Controller 用于对Controller实现类进行标注（web层控制器） 1234567891011//@Component 相同效果@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao;&#125;//@Component 相同效果@Repositorypublic class UserDaoImpl implements UserDao&#123;//......&#125; 有了注解声明，我们就不需要在xml中声明Bean了，但需要告诉Spring注解的Bean在那些包下，因此需要添加包扫描机制，此时需要启用Spring的context命名空间：1&lt;context:component-scan base-package=\"xxx.project\" /&gt; 另外 @Component、@Service和@Repository可以输入一个String值的名称，如果没有提供名称，那么默认情况下就是一个简单的类名(第一个字符小写)变成Bean名称。 1234567891011//@Component(\"userService\") 相同效果@Service(\"userService\")public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao;&#125;//@Component(\"UserDao\") 相同效果@Repository(\"UserDao\")public class UserDaoImpl implements UserDao&#123;//......&#125; （4）项目实践实际项目中，默认会按照byName方式进行依赖注入1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\"&gt; &lt;!-- 注意上面的default-autowire=\"byName\"，如果没有这个声明不会被注入 --&gt; &lt;description&gt;Spring-配置&lt;/description&gt; &lt;!-- 自动扫描组件，这里要把web下面的 controller去除，他们是在servlet-servlet.xml中配置的，如果不去除会影响事务管理的。 --&gt; &lt;context:component-scan base-package=\"xxx\"/&gt; &lt;!-- 用于持有ApplicationContext,可以使用SpringContextHolder.getBean('xxxx')的静态方法得到spring bean对象 --&gt; &lt;bean class=\"xxx.SpringContextHolder\" lazy-init=\"false\" /&gt;&lt;/beans&gt;&lt;/xml&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://qianh.github.io/categories/Spring/"}],"tags":[{"name":"Spring ioc","slug":"Spring-ioc","permalink":"https://qianh.github.io/tags/Spring-ioc/"}]},{"title":"spring","slug":"spring","date":"2018-05-07T02:39:16.000Z","updated":"2019-06-21T06:05:19.726Z","comments":true,"path":"2018/05/07/spring/","link":"","permalink":"https://qianh.github.io/2018/05/07/spring/","excerpt":"","text":"什么是Spring Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为J2EE应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转(IoC)和面向切面(AOP)。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式)轻量级开源框架。 EE开发可分成三层架构，针对JavaEE的三层结构，每一层Spring都提供了不同的解决技术： WEB层：SpringMVC 业务层：Spring的IoC 持久层：Spring的JDBCTemplate(Spring的JDBC模板，ORM模板用于整合其他的持久层框架) Spring的核心有两部分： IoC：控制反转 AOP：面向切面编程 Spring优势 方便解耦，简化开发Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。 AOP编程的支持Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。 声明式事务的支持只需要通过配置就可以完成对事务的管理，而无须手动编程。 方便程序的测试Spring对Junit4支持，可以通过注解方便的测试Spring程序。 方便集成各种优秀的框架Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如：Struts2、Hibernate、MyBatis、Quartz等)的直接支持。 降低JavaEE API的使用难度Spring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)，都提供了封装，使这些API应用难度大大降低。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://qianh.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://qianh.github.io/tags/Spring/"}]},{"title":"java 知识点","slug":"java-knowledge","date":"2018-05-04T02:37:54.000Z","updated":"2019-06-21T06:05:19.725Z","comments":true,"path":"2018/05/04/java-knowledge/","link":"","permalink":"https://qianh.github.io/2018/05/04/java-knowledge/","excerpt":"","text":"整理一些 java 中的常备知识点（1）原始数据类型相关知识原始数据类型(封装类)：boolean(Integer)，byte(Byte)，short(Short)，char(Character)，int(Integer)，float(Float)，long(Long)，double(Double) boolean(封装类 Boolean) boolean 数据类型非 true 即 false。这个数据类型表示 1 bit，但是它的大小并没有精确定义 boolean 类型单独使用是4个字节，在数组中又是1个字节 boolean 不用byte或short，而是使用 int 的原因是：对于32位的CPU来说，一次进行32位的数据交换更加高效 综上，官方文档对boolean类型没有给出精确的定义，《Java虚拟机规范》给出了“单独时使用4个字节，boolean数组时1个字节”的定义，具体还要看虚拟机实现是否按照规范来，所以1个字节、4个字节都是有可能的。这其实是一种时空权衡。 byte(封装类 Byte)byte 使用是 1 个字节, 1 byte = 8 bit short(封装类 Short)short 使用是 2 个字节 char(封装类 Character)char 使用是 2 个字节 int(封装类 Integer)int 使用是 4 个字节 float(封装类 Float)float 单精度浮点数，使用是 4 个字节 long(封装类 Long)long 长整型，使用是 8 个字节 double(封装类 Double)double 双精度浮点数，使用是 8 个字节 （2）”==” 与 “equals()” 的区别 《Thinking in Java》中说：“关系操作符生成的是一个boolean结果，它们计算的是操作数的值之间的关系”。 “==”判断的是两个对象的内存地址是否一样，适用于原始数据类型和枚举类型（它们的变量存储的是值本身，而引用类型变量存储的是引用）； equals是Object类的方法，Object对它的实现是比较内存地址，我们可以重写这个方法来自定义“相等”这个概念。比如类库中的String、Date等类就对这个方法进行了重写。 综上，对于枚举类型和原始数据类型的相等性比较，应该使用”==”；对于引用类型的相等性比较，应该使用equals方法。 （3）Object中定义了哪些方法？1hashCode(),clone(),wait(),notify(),notifyAll(),equals(),toString(),finalize(),getClass() （4）hashCode的作用？在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:1public native int hashCode(); 该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。hashCode方法默认返回对象的内存地址 hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。 场景：当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？ 如果用equals方法，需要逐个比较，但是集合数据多的时候就比较耗性能了。 此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。 java.util.HashMap的中put方法的具体实现：12345678910111213141516171819public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。 equals方法和hashCode方法 在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。 如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。 如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。 在《Java编程思想》一书中的有同第一条类似的一段话： “设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码”。 （5）ArrayList, LinkedList, Vector的区别是什么？ ArrayList: 内部采用数组存储元素，支持高效随机访问，支持动态调整大小 LinkedList: 内部采用链表来存储元素，支持快速插入/删除元素，但不支持高效地随机访问 Vector: 可以看作线程安全版的ArrayList （6）String, StringBuilder, StringBuffer的区别是什么？ String: 不可变的字符序列，若要向其中添加新字符需要创建一个新的String对象 StringBuilder: 可变字符序列，支持向其中添加新字符（无需创建新对象） StringBuffer: 可以看作线程安全版的StringBuilder （7）Map, Set, List, Queue, Stack的特点及用法。 Map&lt;K, V&gt;: Java中存储键值对的数据类型都实现了这个接口，表示“映射表”。支持的两个核心操作是get(Object key)以及put(K key, V value)，分别用来获取键对应的值以及向映射表中插入键值对。 Set: 实现了这个接口的集合类型中不允许存在重复的元素，代表数学意义上的“集合”。它所支持的核心操作有add(E e), remove(Object o), contains(Object o)，分别用于添加元素，删除元素以及判断给定元素是否存在于集中。 List: Java中集合框架中的列表类型都实现了这个接口，表示一种有序序列。支持get(int index), add(E e)等操作。 Queue: Java集合框架中的队列接口，代表了“先进先出”队列。支持add(E element), remove()等操作。 Stack: Java集合框架中表示堆栈的数据类型，堆栈是一种“后进先出”的数据结构。支持push(E item), pop()等操作。 （8）HashMap和HashTable的区别 HashTable是线程安全的，而HashMap不是 HashMap中允许存在null键和null值，而HashTable中不允许 （9）HashMap的实现原理Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表 数组的特点：连续空间，寻址迅速，但是在删除或者添加元素的时候需要有较大幅度的移动，所以查询速度快，增删较慢。 链表正好相反，由于空间不连续，寻址困难，增删元素只需修改指针，所以查询慢、增删快。 为了查询和增删都快的目的，出现了哈希表。 哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。HashMap的底层实现是“基于拉链法的散列表”。 详细分析请参考深入解析HashMap、HashTable （10）ConcurrentHashMap的实现原理 ConcurrentHashMap是支持并发读写的HashMap，它的特点是读取数据时无需加锁，写数据时可以保证加锁粒度尽可能的小。由于其内部采用“分段存储”，只需对要进行写操作的数据所在的“段”进行加锁。 Java并发编程：并发容器之ConcurrentHashMap （11）TreeMap, LinkedHashMap, HashMap的区别是什么？ HashMap的底层实现是散列表，因此它内部存储的元素是无序的； TreeMap的底层实现是红黑树，所以它内部的元素的有序的。排序的依据是自然序或者是创建TreeMap时所提供的比较器（Comparator）对象。 LinkedHashMap可以看作能够记住插入元素的顺序的HashMap。 （12）Collection与Collections的区别是什么？ Collection是Java集合框架中的基本接口； Collections是Java集合框架提供的一个工具类，其中包含了大量用于操作或返回集合的静态方法。 Collections类常用方法总结 （13）Java中的异常层次结构 Throwable类是异常层级中的基类。 Error类表示内部错误，这类错误使我们无法控制的； Exception表示异常，RuntimeException及其子类属于未检查异常，这类异常包括ArrayIndexOutOfBoundsException、NullPointerException等，我们应该通过条件判断等方式语句避免未检查异常的发生。 IOException及其子类属于已检查异常，编译器会检查我们是否为所有可能抛出的已检查异常提供了异常处理器，若没有则会报错。对于未检查异常，我们无需捕获（当然Java也允许我们捕获，但我们应该做的事避免未检查异常的发生）。 （14）Java面向对象的三个特征与含义 三大特征：封装、继承、多态。详细介绍请戳Java面向对象三大特性 （15）Override, Overload的含义与区别 Override表示“重写”，是子类对父类中同一方法的重新定义 Overload表示“重载”，也就是定义一个与已定义方法名称相同但签名不同的新方法 （16）接口与抽象类的区别 接口是一种约定，实现接口的类要遵循这个约定； 抽象类本质上是一个类，使用抽象类的代价要比接口大。接口与抽象类的对比如下： 抽象类中可以包含属性，方法（包含抽象方法与有着具体实现的方法），常量；接口只能包含常量和方法声明。 抽象类中的方法和成员变量可以定义可见性（比如public、private等）；而接口中的方法只能为public（缺省为public）。 一个子类只能有一个父类（具体类或抽象类）；而一个接口可以继承一个或多个接口，一个类也可以实现多个接口。 子类中实现父类中的抽象方法时，可见性可以大于等于父类中的；而接口实现类中的接口 方法的可见性只能与接口中相同（public）。 （17）Java中多态的实现原理 所谓多态，指的就是父类引用指向子类对象，调用方法时会调用子类的实现而不是父类的实现。多态的实现的关键在于“动态绑定”。 Java动态绑定的内部实现机制 （18）简述Java中创建新线程的两种方法 继承Thread类。1）定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。2）创建Thread子类的实例，也就是创建了线程对象3）启动线程，即调用线程的start()方法12345678910public class MyThread extends Thread&#123;//继承Thread类 public void run()&#123; //重写run方法 &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; new MyThread().start();//创建并启动线程 &#125;&#125; 实现Runnable接口。1）定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体。2）创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象。3）第三部依然是通过调用线程对象的start()方法来启动线程。1234567891011121314public class MyThread2 implements Runnable &#123;//实现Runnable接口 public void run()&#123; //重写run方法 &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; //创建并启动线程 MyThread2 myThread=new MyThread2(); Thread thread=new Thread(myThread); thread().start(); //或者 new Thread(new MyThread2()).start(); &#125;&#125; 使用Callable和Future创建线程。 和Runnable接口不一样，Callable接口提供了一个call()方法作为线程执行体，call()方法比run()方法功能要强大。 &gt;&gt;call()方法可以有返回值&gt;&gt;call()方法可以声明抛出异常在Future接口里定义了几个公共方法来控制它关联的Callable任务。 &gt;&gt;boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务&gt;&gt;V get()：返回Callable里call()方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值&gt;&gt;V get(long timeout,TimeUnit unit)：返回Callable里call()方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException&gt;&gt;boolean isDone()：若Callable任务完成，返回True&gt;&gt;boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True具体操作步骤：Callable和Future 一般推荐采用实现接口的方式来创建多线程Java线程专栏文章汇总（19）单例1，懒汉式1234567891011121314public class Single &#123; private static volatile Single instance; private Single() &#123;&#125; public static Single getInstance() &#123; if(instance == null) &#123; synchronized (Single.class) &#123; if(instance == null) &#123; instance = new Single(); &#125; &#125; &#125; return instance; &#125;&#125; 1，饿汉式123456789public class Single2 &#123; private static class SingleHandle() &#123; private static final Single2 instance = new Single2(); &#125; private Single2() &#123;&#125; public static final Single2 getInstance() &#123; return SingleHandle.instance; &#125;&#125; （20）排序算法1 冒泡12345678910111213public void bubbleSort(int[] array) &#123; int temp = 0; for(int i=0;i&lt;array.length-1;i++) &#123; for(int j=0;j&lt;array.length-1-i;j++) &#123; if(array[j] &gt; array[j+1]) &#123; temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(array));&#125; 2 选择123456789101112131415161718public void selectSort(int array[]) &#123; int t = 0; for (int i = 0; i &lt; array.length - 1; i++)&#123; int index=i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[index] &gt; array[j]) &#123; index = j; &#125; &#125; if(index!=i)&#123; //找到了比array[i]小的则与array[i]交换位置 t = array[i]; array[i] = array[index]; array[index] = t; &#125; &#125; System.out.println(Arrays.toString(array));&#125; 3 插入1234567891011public void insertionSort(int array[]) &#123; int i, j, t = 0; for (i = 1; i &lt; array.length; i++) &#123; t = array[i]; for (j = i - 1; j &gt;= 0 &amp;&amp; t &lt; array[j]; j--) &#123; array[j + 1] = array[j]; &#125; array[j + 1] = t; &#125; System.out.println(Arrays.toString(array));&#125;","categories":[{"name":"java","slug":"java","permalink":"https://qianh.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://qianh.github.io/tags/java/"}]},{"title":"java源代码赏析 —— String类","slug":"java-String","date":"2018-05-03T05:17:21.000Z","updated":"2019-06-21T06:05:19.722Z","comments":true,"path":"2018/05/03/java-String/","link":"","permalink":"https://qianh.github.io/2018/05/03/java-String/","excerpt":"","text":"(1) String类声明String类实现了序列化、比较器两个接口，用final修饰符说明该类不能被其他类继承，其他类不能重写该类已有的方法123package java.lang; //定义在java.lang包下public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequece (2) 字符串的本质是 char[]12/** The value is used for character storage. */ //该数组用于字符存储private final char value[]; //String 类底层是 char 数组 (3) String 类的无参构造方法123public String &#123; this.value = new char[0]; //构造一个空串&#125; (4) String 类的其他参构造方法4.1 String类型1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 4.2 使用 char[] 构造一个字符串调用 Arrays 类字符串拷贝函数复制一份字符完成构造123456789101112131415161718public String(Char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125;public String(Char value[], int offset, int count) &#123; //处理非法参数 if(offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if(count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; //Note: offset or count might be near -1&gt;&gt;&gt;1. if(offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; //参数合法，调用字符串复制函数复制目标char[]到value[] this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 4.3 int[] 构造一个字符串1234567891011121314151617181920212223242526272829303132333435363738public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++); &#125; this.value = v;&#125; 4.4 bytes[] 构造一个字符串123456789101112131415161718192021222324252627282930313233public String(byte bytes[]) &#123; this(bytes, 0, bytes.length);&#125;public String(byte bytes[], int offset, int length) &#123; //offset 是起始位置，length是从起始位置计要构造字符串的长度 checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length);&#125;public String(byte bytes[], int offset, int length, String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(\"charsetName\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charsetName, bytes, offset, length);&#125;public String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException(\"charset\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length);&#125;public String(byte bytes[], String charsetName) throws UnsupportedEncodingException &#123; this(bytes, 0, bytes.length, charsetName);&#125;public String(byte bytes[], Charset charset) &#123; this(bytes, 0, bytes.length, charset);&#125; 4.5 StringBuffer（线程安全） 构造一个字符串12345public String(StringBuffer buffer) &#123; synchronized(buffer) &#123; this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); &#125;&#125; 4.6 StringBuilder（线程不安全） 构造一个字符串123public String(StringBuilder builder) &#123; this.value = Arrays.copyOf(builder.getValue(), builder.length());&#125; (5) 检查边界的函数如果越界会抛出异常 StringIndexOutOfBoundsException1234567891011private static void checkBounds(byte[] bytes, int offset, int length) &#123; if(length &lt; 0) &#123; throw new StringIndexOutOfBoundsException(length); &#125; if(offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if(offset &gt; bytes.length - length) &#123; throw new StringIndexOutOfBoundsException(offset + length); &#125;&#125; (6) 获取字符串的长度字符串的长度也就是value数组的长度，即有效字的个数。123public int length() &#123; return value.length;&#125; (7) 判断字符串是否是空串123public boolean isEmpty() &#123; return value.length == 0; //判断其有效字符个数是否为0&#125; (8) 获取某一位置的字符如果传入的索引合法，就返回该位置的字符123456public char charAt(int index) &#123; if((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index];&#125; (9) 获取某一位置的字符对应的 int 值123456public int codePointAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointAtImpl(value, index, value.length);&#125; (10) 将字符串转换为 byte[] 数组123public byte[] getBytes() &#123; return StringCoding.encode(value, 0, value.length);&#125; (11) (重要) 字符串比较函数 equals()不同于 “==” 比较，该函数比较的是字符串的内容而非引用，前者比较的是引用（地址）1234567891011121314151617181920212223public boolean equals(Object anObject) &#123; //使用Object类接收，向上转型 if(this == anObject) &#123; return true; &#125; if(anObject instanceof String) &#123; //确定是否是String类的对象 String anotherString = (String)anObject;//强制转换为String int n = value.length; //先比较长度,再比较内容 if(n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while(n-- != 0) &#123; if(v1[i] != v2[i]) &#123; return false; i++; &#125; &#125; return true; &#125; &#125; return false; //不是String类型，返回false&#125; (12) 比较两个字符串内容，忽略大小写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length);&#125;public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. // 先转大写进行比较 char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. // 如果转大写比较不成功（由于某种原因），转小写再进行比较一次 if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true;&#125; (13) 判断该字符串是否以某个指定字符串开头123456789101112131415161718192021public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1&gt;&gt;&gt;1. if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true;&#125;public boolean startsWith(String prefix) &#123; return startsWith(prefix, 0);&#125; (14) 判断该字符串是否以某个指定字符串结尾123public boolean endsWith(String suffix) &#123; return startsWith(suffix, value.length - suffix.value.length);&#125; (15) hashCode 生成规则123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123;// 没有生成过的时候才进入 char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; (16) 查找字符串的位置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int indexOf(String str) &#123; return indexOf(str, 0);&#125;public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125;static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; //source 原值， target 查找目标值， offset 起始位置， count 字符串长度 //fromIndex 开始查找的位置 if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1;&#125; (17) 查找字符串的最后位置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int lastIndexOf(String str) &#123; return lastIndexOf(str, value.length);&#125;public int lastIndexOf(String str, int fromIndex) &#123; return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125;static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; /* * Check arguments; return immediately where possible. For * consistency, don't check for null str. */ int rightIndex = sourceCount - targetCount; if (fromIndex &lt; 0) &#123; return -1; &#125; if (fromIndex &gt; rightIndex) &#123; fromIndex = rightIndex; &#125; /* Empty string always matches. */ if (targetCount == 0) &#123; return fromIndex; &#125; int strLastIndex = targetOffset + targetCount - 1; char strLastChar = target[strLastIndex]; int min = sourceOffset + targetCount - 1; int i = min + fromIndex;startSearchForLastChar: while (true) &#123; while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; if (i &lt; min) &#123; return -1; &#125; int j = i - 1; int start = j - (targetCount - 1); int k = strLastIndex - 1; while (j &gt; start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125; &#125; return start - sourceOffset + 1; &#125;&#125; (18) 截取子串12345678910111213141516171819202122232425public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125;public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);&#125; (19) 字符串连接12345678910111213141516171819public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125;void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length);&#125;String(char[] value, boolean share) &#123; // assert share : \"unshared not supported\"; this.value = value;&#125; (20) 替换全部替换原字符串中符合要求的所有片段123456789101112131415161718192021222324252627282930public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j]; &#125; while (i &lt; len) &#123; char c = val[i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(buf, true); &#125; &#125; return this;&#125;public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement);&#125; (21) 是否匹配该正则表达式123public boolean matches(String regex) &#123; return Pattern.matches(regex, this);&#125; (22) 是否包含该字符123public boolean contains(CharSequence s) &#123; return indexOf(s.toString()) &gt; -1;&#125; (23) 字符串拆分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public String[] split(String regex) &#123; return split(regex, 0);&#125;public String[] split(String regex, int limit) &#123; /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters \".$|()[&#123;^?*+\\\\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.value.length == 1 &amp;&amp; \".$|()[&#123;^?*+\\\\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) &#123; while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123; resultSize--; &#125; &#125; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit);&#125; (24) 去除两端空格12345678910111213public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;&#125; (25) toString 方法123public String toString() &#123; return this;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://qianh.github.io/categories/java/"}],"tags":[{"name":"java 源码","slug":"java-源码","permalink":"https://qianh.github.io/tags/java-源码/"}]},{"title":"java源代码赏析 —— Object类","slug":"java-Object","date":"2018-05-02T05:10:56.000Z","updated":"2019-06-21T06:34:06.411Z","comments":true,"path":"2018/05/02/java-Object/","link":"","permalink":"https://qianh.github.io/2018/05/02/java-Object/","excerpt":"","text":"Object类 —— 一切类的父类(1) Object类的声明12package java.lang; //Object 类定义在java.lang 包下public class Object (2) registerNatives 方法通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。1234private static native void registerNatives();static &#123; registerNatives();&#125; (3) hashCode 方法1public native int hashCode(); (4) (重要) equals() 方法 —— 比较对象的引用Object类的equals()方法比较的是对象的引用而不是内容，这与实际生活的情况不符，实际生活中人们要求比较的是内容,比较引用没有意义，所以其他类继承Object类之后,往往需要重写equals()方法123public boolean equals(Object obj) &#123; return (this == obj)&#125; (5) (重要) toString() 方法 —— 打印对象的信息打印一个对象就是调用toString()方法，该方法打印这个对象的信息，其他类在继承Object类后，一般要重写此方法，设置打印关于对象的信息的操作。123public String toString() &#123; return getClass().getName()+\"@\"+Integer.toHexString(hashCode());&#125; (6) 线程的等待1234public final void wait() throws InterruptedException &#123; wait(0);&#125;public final native void wait(long timeout) throws InterruptedException; 还可以指定等待的最长毫秒和纳秒123456789101112public final void wait(long timeout, int nanos) throws InterruptedException &#123; if(timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if(nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException(\"nanosecond timeout value out of range\"); &#125; if(nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) &#123; timeout++; &#125; wait(timeout);&#125; (7) 唤醒等待的线程7.1 唤醒一个线程1public final native void notify(); 7.2 唤醒全部线程唤醒全部线程，哪个线程的优先级高，他就有可能先执行1public final native void notifyAll(); (8) finalize() 方法 —— 对象的回收当确定一个对象不会被其他方法再使用时，该对象就没有存在的意义了，就只能等待JVM的垃圾回收线程来回收了。垃圾回收是以占用一定内存为代价的。System.gc();就是启动垃圾回收线程的语句。当用户认为需要回收时，可以使用Runtime.getRuntime().gc();或者System.gc();来回收内存。（System.gc();调用的就是Runtime类的 gc()方法）当一个对象在回收前想要执行一些操作，就要覆写Object类中的finalize()方法。1protected void finalize() throws Throwable &#123;&#125; 注意到抛出的是Throwable，说明除了常规的异常Exception外，还有可能是JVM错误。说明调用该方法不一定只会在程序中产生异常，还有可能产生JVM错误。（9）clone()方法 —— 用于对象克隆Object类的直接或间接子类通过在重写该方法并直接调用本类的该方法完成对象克隆。1protected native Object clone() throws CloneNotSupportedException; native 关键字表示调用本机操作系统的函数。","categories":[{"name":"java","slug":"java","permalink":"https://qianh.github.io/categories/java/"}],"tags":[{"name":"java 源码","slug":"java-源码","permalink":"https://qianh.github.io/tags/java-源码/"}]}]}