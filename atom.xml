<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>John</title>
  
  <subtitle>个人博客，活到老学到老</subtitle>
  <link href="/child/atom.xml" rel="self"/>
  
  <link href="https://blog.john-qh.com/"/>
  <updated>2019-06-21T06:05:19.722Z</updated>
  <id>https://blog.john-qh.com/</id>
  
  <author>
    <name>John</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java源代码赏析 —— 迭代器（Iterator）</title>
    <link href="https://blog.john-qh.com/2018/05/14/java-iterator/"/>
    <id>https://blog.john-qh.com/2018/05/14/java-iterator/</id>
    <published>2018-05-14T13:25:54.000Z</published>
    <updated>2019-06-21T06:05:19.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-java集合类都在java-util包下，都可以追溯到一个接口——iterator-迭代器-。"><a href="#1-java集合类都在java-util包下，都可以追溯到一个接口——iterator-迭代器-。" class="headerlink" title="(1) java集合类都在java.util包下，都可以追溯到一个接口——iterator(迭代器)。"></a>(1) java集合类都在java.util包下，都可以追溯到一个接口——iterator(迭代器)。</h4><h5 id="iterator是对原java-Enumeration的替代。下图展示了java集合家族的关系："><a href="#iterator是对原java-Enumeration的替代。下图展示了java集合家族的关系：" class="headerlink" title="iterator是对原java Enumeration的替代。下图展示了java集合家族的关系："></a>iterator是对原java Enumeration的替代。下图展示了java集合家族的关系：</h5><p><img src="/2018/05/14/java-iterator/iterator.png" alt="java集合家谱"></p><h4 id="2-iterator-接口方法："><a href="#2-iterator-接口方法：" class="headerlink" title="(2) iterator 接口方法："></a>(2) iterator 接口方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//如果迭代器中还有元素，则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回迭代器中的下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//删除迭代器新返回的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为每个剩余元素执行给定的操作,直到所有的元素都已经被处理或行动将抛出一个异常</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对于-hasNext-next-remove-用List来实际操作一下用法："><a href="#对于-hasNext-next-remove-用List来实际操作一下用法：" class="headerlink" title="对于 hasNext(),next(),remove(),用List来实际操作一下用法："></a>对于 hasNext(),next(),remove(),用List来实际操作一下用法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"a"</span>);</span><br><span class="line">    list.add(<span class="string">"b"</span>);</span><br><span class="line">    list.add(<span class="string">"c"</span>);</span><br><span class="line">    Iterator i = l.iterator();</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        System.out.println(i.next());</span><br><span class="line">        i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"list size:"</span>+list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出结果：</span></span><br><span class="line"><span class="comment">* a</span></span><br><span class="line"><span class="comment">* b</span></span><br><span class="line"><span class="comment">* c</span></span><br><span class="line"><span class="comment">* list size:0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3-与之相近的-iterable-java-lang包下"><a href="#3-与之相近的-iterable-java-lang包下" class="headerlink" title="(3) 与之相近的 iterable (java.lang包下)"></a>(3) 与之相近的 iterable (java.lang包下)</h4><h5 id="Collection实现了iterable接口，-iterable接口提供方法："><a href="#Collection实现了iterable接口，-iterable接口提供方法：" class="headerlink" title="Collection实现了iterable接口， iterable接口提供方法："></a>Collection实现了iterable接口， iterable接口提供方法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="iterable-提供了获取Iterator的方法，可以获得Iterator迭代器的相应功能。"><a href="#iterable-提供了获取Iterator的方法，可以获得Iterator迭代器的相应功能。" class="headerlink" title="iterable 提供了获取Iterator的方法，可以获得Iterator迭代器的相应功能。"></a>iterable 提供了获取Iterator的方法，可以获得Iterator迭代器的相应功能。</h5><h4 id="4-Iterator和Iterable-区别："><a href="#4-Iterator和Iterable-区别：" class="headerlink" title="(4) Iterator和Iterable 区别："></a>(4) Iterator和Iterable 区别：</h4><h5 id="4-1-所属包不同，Iterator在java-util包下，Iterable在java-lang包下"><a href="#4-1-所属包不同，Iterator在java-util包下，Iterable在java-lang包下" class="headerlink" title="4.1 所属包不同，Iterator在java.util包下，Iterable在java.lang包下"></a>4.1 所属包不同，Iterator在java.util包下，Iterable在java.lang包下</h5><h5 id="4-2-Iterator是迭代器类，而Iterable是接口。"><a href="#4-2-Iterator是迭代器类，而Iterable是接口。" class="headerlink" title="4.2 Iterator是迭代器类，而Iterable是接口。"></a>4.2 Iterator是迭代器类，而Iterable是接口。</h5><h5 id="4-3-Iterator接口的核心方法next-或者hasNext-是依赖于迭代器的当前迭代位置的。-如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据-指针-。-当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next-方法的结果会变成不可预知。-除非再为Iterator接口添加一个reset-方法，用来重置当前迭代位置。-但即时这样，Collection也只能同时存在一个当前迭代位置。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。-多个迭代器是互不干扰的。"><a href="#4-3-Iterator接口的核心方法next-或者hasNext-是依赖于迭代器的当前迭代位置的。-如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据-指针-。-当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next-方法的结果会变成不可预知。-除非再为Iterator接口添加一个reset-方法，用来重置当前迭代位置。-但即时这样，Collection也只能同时存在一个当前迭代位置。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。-多个迭代器是互不干扰的。" class="headerlink" title="4.3 Iterator接口的核心方法next()或者hasNext() 是依赖于迭代器的当前迭代位置的。 如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。  当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。  除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 但即时这样，Collection也只能同时存在一个当前迭代位置。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。 多个迭代器是互不干扰的。"></a>4.3 Iterator接口的核心方法next()或者hasNext() 是依赖于迭代器的当前迭代位置的。 如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。  当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。  除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 但即时这样，Collection也只能同时存在一个当前迭代位置。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。 多个迭代器是互不干扰的。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-java集合类都在java-util包下，都可以追溯到一个接口——iterator-迭代器-。&quot;&gt;&lt;a href=&quot;#1-java集合类都在java-util包下，都可以追溯到一个接口——iterator-迭代器-。&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="java" scheme="https://blog.john-qh.com/categories/java/"/>
    
    
      <category term="java 源码" scheme="https://blog.john-qh.com/tags/java-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>spring-aop</title>
    <link href="https://blog.john-qh.com/2018/05/08/spring-aop/"/>
    <id>https://blog.john-qh.com/2018/05/08/spring-aop/</id>
    <published>2018-05-08T06:16:51.000Z</published>
    <updated>2019-06-21T06:05:19.725Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h4><blockquote><p>分布于应用中多处的功能被称为<strong>横切关注点</strong>（cross-cutting concerns）。通常，这些横切关注点从概念上是于应用的业务逻辑相分离的（但是往往直接潜入到应用的业务逻辑之中）。将这些横切关注点于业务逻辑相分离正是面向切面编程（AOP）所要解决的。——《Spring实战》</p></blockquote><h4 id="2-什么是面向切面编程"><a href="#2-什么是面向切面编程" class="headerlink" title="2.什么是面向切面编程"></a>2.什么是面向切面编程</h4><p>  继承与委托是最常见的实现重用通用功能的面向对象技术。但是我们不太会在应用中使用相同的基类，而使用委托需要对委托对象进行复杂的调用。<br>  切面提供了取代继承和委托的另一种选择，在很多场景下更清晰简洁。横切关注点可以被模块化为特殊的类，这些类被称为切面。<br>  这样做有两个好处：</p><ol><li>每个关注点现在只集中于一处，而不是分散于多处代码中；</li><li>服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</li></ol><h4 id="3-AOP术语"><a href="#3-AOP术语" class="headerlink" title="3.AOP术语"></a>3.AOP术语</h4><p>  与大多数技术一样，AOP已经形成了自己的术语。描述切面的常用术语有<strong>通知（advice）、切点（pointcut）和连接点（join point）</strong></p><h5 id="3-1-通知（advice）"><a href="#3-1-通知（advice）" class="headerlink" title="3.1 通知（advice）"></a>3.1 通知（advice）</h5><p>在AOP术语中，切面的工作被称为通知。Spring切面可以应用5种类型的通知：</p><ul><li>Before——在方法被调用之前调用通知。</li><li>After——在方法完成之后调用通知，无论方法执行是否成功。</li><li>After-returning——在方法成功执行之后调用通知。</li><li>After-throwing——在方法抛出异常后调用通知。</li><li>Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul><h5 id="3-2-连接点（Joinpoint）"><a href="#3-2-连接点（Joinpoint）" class="headerlink" title="3.2 连接点（Joinpoint）"></a>3.2 连接点（Joinpoint）</h5><ul><li>我们的应用程序可能需要对数以千计的时机应用通知，这些时机被称为连接点。</li><li>连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</li></ul><h5 id="3-3-切点（Pointcut）"><a href="#3-3-切点（Pointcut）" class="headerlink" title="3.3 切点（Pointcut）"></a>3.3 切点（Pointcut）</h5><ul><li>一个切面并不需要通知应用中所有的连接点，切点有助于缩小切面所通知的连接点的范围。</li><li>切点的定义会匹配通知所有要织入的一个或多个连接点。</li><li>通常使用明确的类和方法名称来指定这些切点，或是利用正则表达式定义匹配的类和方法名称模式来指定这些切点。</li></ul><h5 id="3-4-切面（Aspect）"><a href="#3-4-切面（Aspect）" class="headerlink" title="3.4 切面（Aspect）"></a>3.4 切面（Aspect）</h5><ul><li>切面是通知和切点的结合。</li><li>通知和切点共同定义了关于切面的全部内容——它是什么，在何时完成其功能。</li></ul><h5 id="3-5-引入（Introduction）"><a href="#3-5-引入（Introduction）" class="headerlink" title="3.5 引入（Introduction）"></a>3.5 引入（Introduction）</h5><p>引入允许我们向现有的类添加新的方法或属性</p><h5 id="3-6-织入（Weaving）"><a href="#3-6-织入（Weaving）" class="headerlink" title="3.6 织入（Weaving）"></a>3.6 织入（Weaving）</h5><p>织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ol><li>编译期——切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期——切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入之前增强该目标类的字节码。AspectJ 5的LTW就支持以这种方式织入切面。</li><li>运行期——切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器回会目标对象动态创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li></ol><h4 id="4-Spring-AOP"><a href="#4-Spring-AOP" class="headerlink" title="4.Spring AOP"></a>4.Spring AOP</h4><h5 id="4-1-Spring-提供了4种各具特色的AOP支持："><a href="#4-1-Spring-提供了4种各具特色的AOP支持：" class="headerlink" title="4.1 Spring 提供了4种各具特色的AOP支持："></a>4.1 Spring 提供了4种各具特色的AOP支持：</h5><ul><li>基于代理的经典AOP；</li><li>@AspectJ 注解驱动的切面；</li><li>纯POJO切面；</li><li>注入式AspectJ切面（适合Spring各版本）</li></ul><h5 id="Spring-对AOP的支持局限于方法拦截，且只支持方法连接点（不支持字段和构造器接入点）。"><a href="#Spring-对AOP的支持局限于方法拦截，且只支持方法连接点（不支持字段和构造器接入点）。" class="headerlink" title="Spring 对AOP的支持局限于方法拦截，且只支持方法连接点（不支持字段和构造器接入点）。"></a><font color="#dd0000">Spring 对AOP的支持局限于方法拦截，且只支持方法连接点（不支持字段和构造器接入点）。</font></h5><h5 id="4-2-使用切点选择连接点"><a href="#4-2-使用切点选择连接点" class="headerlink" title="4.2 使用切点选择连接点"></a>4.2 使用切点选择连接点</h5><ul><li>execution指示器是编写切点定义时最主要使用的指示器。</li><li>execution()编写规则如：execution(<em> xxx.xxx.xxx.impl..</em>.*(..))</li></ul><h5 id="4-3-在XML中声明切面"><a href="#4-3-在XML中声明切面" class="headerlink" title="4.3 在XML中声明切面"></a>4.3 在XML中声明切面</h5><p>Spring的AOP配置元素简化了基于POJO切面的声明：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span>&gt;</span> <span class="comment">&lt;!-- 定义AOP通知器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after</span>&gt;</span> <span class="comment">&lt;!-- 定义AOP后置通知（不管被通知的方法是否执行成功） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span>&gt;</span> <span class="comment">&lt;!-- 定义AOP after-returning 通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span>&gt;</span> <span class="comment">&lt;!-- 定义AOP after-throwing 通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:around</span>&gt;</span> <span class="comment">&lt;!-- 定义AOP 环绕通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span> <span class="comment">&lt;!-- 定义切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-antoproxy</span>&gt;</span> <span class="comment">&lt;!-- 启用@AspectJ 注解驱动的切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span>&gt;</span> <span class="comment">&lt;!-- 定义AOP 前置通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span> <span class="comment">&lt;!-- 顶层的AOP配置元素。大多数的&lt;aop:*&gt;元素必须包含在&lt;aop:config&gt;元素内 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:declare</span>&gt;</span> <span class="comment">&lt;!-- 为被通知的对象引入额外的接口，并透明地实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span>&gt;</span> <span class="comment">&lt;!-- 定义切点 --&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="4-4-使用例子"><a href="#4-4-使用例子" class="headerlink" title="4.4 使用例子"></a>4.4 使用例子</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxxHandler"</span> <span class="attr">class</span>=<span class="string">"xxx.BusinessExceptionAop"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brave"</span> <span class="attr">value</span>=<span class="string">"#&#123;brave&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"xxxHandler"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"exceptionService"</span> <span class="attr">expression</span>=<span class="string">"execution(* xxx.impl..*.*(..))"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"exceptionService"</span> <span class="attr">method</span>=<span class="string">"afterThrowing"</span> <span class="attr">throwing</span>=<span class="string">"e"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.背景&quot;&gt;&lt;/a&gt;1.背景&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;分布于应用中多处的功能被称为&lt;strong&gt;横切关注点&lt;/strong&gt;（cross-cuttin
      
    
    </summary>
    
      <category term="Spring" scheme="https://blog.john-qh.com/categories/Spring/"/>
    
    
      <category term="Spring aop" scheme="https://blog.john-qh.com/tags/Spring-aop/"/>
    
  </entry>
  
  <entry>
    <title>spring-ioc</title>
    <link href="https://blog.john-qh.com/2018/05/07/spring-ioc/"/>
    <id>https://blog.john-qh.com/2018/05/07/spring-ioc/</id>
    <published>2018-05-07T06:16:26.000Z</published>
    <updated>2019-06-21T06:05:19.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考：关于spring-ioc"><a href="#参考：关于spring-ioc" class="headerlink" title="参考：关于spring ioc"></a>参考：<a href="https://blog.csdn.net/javazejian/article/details/54561302" target="_blank" rel="noopener">关于spring ioc</a></h3><h4 id="（1）IOC-Inversion-of-Control"><a href="#（1）IOC-Inversion-of-Control" class="headerlink" title="（1）IOC(Inversion of Control)"></a>（1）IOC(Inversion of Control)</h4><blockquote><p>IOC，另外一种说法叫DI（Dependency Injection），即依赖注入。它并不是一种技术实现，而是一种设计思想。在任何一个有实际开发意义的程序项目中，我们会使用很多类来描述它们特有的功能，并且通过类与类之间的相互协作来完成特定的业务逻辑。这个时候，每个类都需要负责管理与自己有交互的类的引用和依赖，代码将会变的异常难以维护和极度的高耦合。而IOC的出现正是用来解决这个问题，我们通过IOC将这些相互依赖对象的创建、协调工作交给Spring容器去处理，每个对象只需要关注其自身的业务逻辑关系就可以了。在这样的角度上来看，<strong>获得依赖的对象的方式，进行了反转，变成了由spring容器控制对象如何获取外部资源（包括其他对象和文件资料等等）</strong>。</p></blockquote><blockquote><p>Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p></blockquote><h5 id="总结：ioc-最主要的是改变了以往的编程思想，由原先通过-new-的方式获取依赖对象的方式（正转），变成了由spring容器来进行实例化（反转），应用程序由主动变成了被动接受。"><a href="#总结：ioc-最主要的是改变了以往的编程思想，由原先通过-new-的方式获取依赖对象的方式（正转），变成了由spring容器来进行实例化（反转），应用程序由主动变成了被动接受。" class="headerlink" title="总结：ioc 最主要的是改变了以往的编程思想，由原先通过 new 的方式获取依赖对象的方式（正转），变成了由spring容器来进行实例化（反转），应用程序由主动变成了被动接受。"></a>总结：ioc 最主要的是改变了以往的编程思想，由原先通过 new 的方式获取依赖对象的方式（正转），变成了由spring容器来进行实例化（反转），应用程序由主动变成了被动接受。</h5><h4 id="（2）具体使用（自动装配与注解注入）"><a href="#（2）具体使用（自动装配与注解注入）" class="headerlink" title="（2）具体使用（自动装配与注解注入）"></a>（2）具体使用（自动装配与注解注入）</h4><ul><li>Spring的自动装配有三种模式：<strong>byType(根据类型)，byName(根据名称)、constructor(根据构造函数)。</strong></li></ul><h5 id="2-1-byType"><a href="#2-1-byType" class="headerlink" title="2.1 byType"></a>2.1 byType</h5><p>在byTpye模式中，Spring容器会基于反射查看bean定义的类，然后找到与依赖类型相同的bean注入到另外的bean中，<strong>这个过程需要借助setter注入来完成，因此必须存在set方法，否则注入失败。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dao层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDaoImpl doSomething ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//service层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要注入的依赖</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于xml的配置如下，通过使用＜bean＞中的autowire属性为”byType”，按类型自动装配 userService<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"xxx.dao.impl.UserDaoImpl"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- byType 根据类型自动装配userDao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span> <span class="attr">class</span>=<span class="string">"xxx.service.impl.UserServiceImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>byType模式可能存一种注入失败的情况：由于是基于类型的注入，因此当xml文件中存在多个相同类型名称不同的实例Bean时，Spring容器依赖注入仍然会失败，因为存在多种适合的选项，Spring容器无法知道该注入那种。<br>恰好spring为我们提供了解决方案（指定注入需要的Bean实例）：通过设置＜bean＞标签的autowire-candidate为false，来过滤那些不需要注入的实例Bean<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"xxx.dao.impl.UserDaoImpl"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- autowire-candidate="false" 过滤该类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao2"</span> <span class="attr">autowire-candidate</span>=<span class="string">"false"</span> <span class="attr">class</span>=<span class="string">"xxx.dao.impl.UserDaoImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="2-2-byName-实际项目中用得比较多"><a href="#2-2-byName-实际项目中用得比较多" class="headerlink" title="2.2 byName(实际项目中用得比较多)"></a>2.2 byName(实际项目中用得比较多)</h5><p>byName模式的自动装配：Spring只会尝试将属性名与bean名称进行匹配，如果找到则注入依赖bean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span>  <span class="attr">class</span>=<span class="string">"xxx.dao.impl.UserDaoImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao2"</span> <span class="attr">class</span>=<span class="string">"xxx.dao.impl.UserDaoImpl"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- byName 根据名称自动装配，找到UserServiceImpl名为 userDao属性并注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span> <span class="attr">class</span>=<span class="string">"xxx.service.impl.UserServiceImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="基于注解的自动装配-Autowired-amp-Resource-amp-Value"><a href="#基于注解的自动装配-Autowired-amp-Resource-amp-Value" class="headerlink" title="基于注解的自动装配(@Autowired&amp;@Resource&amp;@Value)"></a>基于注解的自动装配(@Autowired&amp;@Resource&amp;@Value)</h5><h6 id="1-Autowired"><a href="#1-Autowired" class="headerlink" title="1) @Autowired"></a>1) @Autowired</h6><ul><li>上述的用法可以用在bean数量很少的情况下，如果数量过多，都需要手动配置xml的话，显然不太优雅，也不利于维护</li><li>好在Spring 2.5 中引入了 @Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用标注到成员变量时不需要有set方法，@Autowired 默认按类型匹配的</li></ul><p>在xml配置文件中加入以下配置信息：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标注成员变量</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@Autowired中还传递了一个required=false的属性，false指明当userDao实例存在就注入不存在就忽略；如果为true，就必须注入，若userDao实例不存在，就抛出异常。<br>由于@Autowired默认情况下是按类型匹配的(byType)，如果想要按名称(byName)匹配的话，可以使用@Qualifier注解与@Autowired结合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标注成员变量</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userDao1"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h6 id="2-Resource"><a href="#2-Resource" class="headerlink" title="2) @Resource"></a>2) @Resource</h6><p>@Autowried具备相同功效，但是默认按 byName模式 自动注入,依赖包是 javax.annotation.Resource 可以标注在成员变量和set方法上，但无法标注构造函数。<br>@Resource有两个中重要的属性：name和type。Spring容器对于@Resource注解的name属性解析为bean的名字，type属性则解析为bean的类型。<br>若设置name属性，则按byName模式的自动注入，若设置type属性则按 byType模式自动注入。如果都不指定，Spring容器将通过反射技术默认按byName模式注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Autowired标注成员变量</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;  </span><br><span class="line"><span class="comment">//上述代码等价于@Resource</span></span><br><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">private</span> UserDao  userDao;<span class="comment">//用于成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用于set方法标注</span></span><br><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.userDao= userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="3-Value"><a href="#3-Value" class="headerlink" title="3) @Value"></a>3) @Value</h6><p>以上两种自动装配的依赖注入并不适合简单值类型，如int、boolean、long、String以及Enum等，对于这些类型，Spring容器提供了@Value注入的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标注成员变量</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//占位符方式</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.address&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//SpEL表达方式，其中代表xml配置文件中的id值configProperties</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;configProperties['jdbc.username']&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="（3）IOC管理-bean"><a href="#（3）IOC管理-bean" class="headerlink" title="（3）IOC管理 bean"></a>（3）IOC管理 bean</h4><h5 id="3-1-Bean的命名"><a href="#3-1-Bean的命名" class="headerlink" title="3.1 Bean的命名"></a>3.1 Bean的命名</h5><p>每一个交给Spring IOC容器创建的对象必须被分配至少一个名称，如果开发者没有提供，Spring容器将会为其分配一个内部名称，通过Bean的名称，我们可以在其他类中查找该类并使用它，如前面的案例，也是通过Bean名称获取到实际对象并执行对应的操作。在基于xml的配置信息中，可以使用id属性来为一个Bean分配名称，在同一个xml配置文件中，<font color="#dd0000">id必须是唯一的，但不同的xml可以相同</font>，当然还可以使用name来为Bean分配名称，name属性可以分配多个名称，此时可使用空格、逗号、分号来分离给定Bean分配多个名称，而id属性则无法这样使用。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name属性配置多个名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userDao,userDao1"</span> <span class="attr">class</span>=<span class="string">"xxx.dao.impl.UserDaoImpl"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id属性配置唯一名称而且不能与name相同--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao2"</span> <span class="attr">class</span>=<span class="string">"xxx.dao.impl.UserDaoImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>上述的Bean对象声明使用都在xml内声明手动声明的方式，一旦Bean对象多起来，管理Bean就会变得复杂。<br>因此Spring提供了基于Java注解的配置方式，分别使用org.springframework.stereotype.Service（@Service）和org.springframework.stereotype.Repository（@Repository）声明XxxServiceImpl和XxxDaoImpl类，使用@Autowired注解注入xxxDao（需要在xml声明注解驱动），或者使用（@Component）。</p><blockquote><p>Spring的框架中提供了与@Component注解等效的三个注解，@Repository 用于对DAO实现类进行标注，@Service 用于对Service实现类进行标注，@Controller 用于对Controller实现类进行标注（web层控制器）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component 相同效果</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@Component 相同效果</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了注解声明，我们就不需要在xml中声明Bean了，但需要告诉Spring注解的Bean在那些包下，因此需要添加包扫描机制，此时需要启用Spring的context命名空间：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"xxx.project"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>另外 @Component、@Service和@Repository可以输入一个String值的名称，如果没有提供名称，那么默认情况下就是一个简单的类名(第一个字符小写)变成Bean名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component("userService") 相同效果</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@Component("UserDao") 相同效果</span></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"UserDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）项目实践"><a href="#（4）项目实践" class="headerlink" title="（4）项目实践"></a>（4）项目实践</h4><h5 id="实际项目中，默认会按照byName方式进行依赖注入"><a href="#实际项目中，默认会按照byName方式进行依赖注入" class="headerlink" title="实际项目中，默认会按照byName方式进行依赖注入"></a>实际项目中，默认会按照byName方式进行依赖注入</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        注意上面的default-autowire="byName"，如果没有这个声明不会被注入</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring-配置<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        自动扫描组件，这里要把web下面的</span></span><br><span class="line"><span class="comment">        controller去除，他们是在servlet-servlet.xml中配置的，如果不去除会影响事务管理的。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用于持有ApplicationContext,可以使用SpringContextHolder.getBean('xxxx')的静态方法得到spring bean对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"xxx.SpringContextHolder"</span> <span class="attr">lazy-init</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考：关于spring-ioc&quot;&gt;&lt;a href=&quot;#参考：关于spring-ioc&quot; class=&quot;headerlink&quot; title=&quot;参考：关于spring ioc&quot;&gt;&lt;/a&gt;参考：&lt;a href=&quot;https://blog.csdn.net/javazej
      
    
    </summary>
    
      <category term="Spring" scheme="https://blog.john-qh.com/categories/Spring/"/>
    
    
      <category term="Spring ioc" scheme="https://blog.john-qh.com/tags/Spring-ioc/"/>
    
  </entry>
  
  <entry>
    <title>spring</title>
    <link href="https://blog.john-qh.com/2018/05/07/spring/"/>
    <id>https://blog.john-qh.com/2018/05/07/spring/</id>
    <published>2018-05-07T02:39:16.000Z</published>
    <updated>2019-06-21T06:05:19.726Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h4><blockquote><p>Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为J2EE应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。<strong>Spring的核心是控制反转(IoC)和面向切面(AOP)。</strong>简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式)轻量级开源框架。</p></blockquote><p>EE开发可分成三层架构，针对JavaEE的三层结构，每一层Spring都提供了不同的解决技术：</p><ul><li>WEB层：<a href="">SpringMVC</a></li><li>业务层：<a href="/2018/05/07/spring-ioc/">Spring的IoC</a></li><li>持久层：Spring的JDBCTemplate(Spring的JDBC模板，ORM模板用于整合其他的持久层框架)</li></ul><p>Spring的核心有两部分：</p><ul><li><a href="/2018/05/07/spring-ioc/">IoC：控制反转</a></li><li><a href="/2018/05/08/spring-aop/">AOP：面向切面编程</a> </li></ul><h4 id="Spring优势"><a href="#Spring优势" class="headerlink" title="Spring优势"></a>Spring优势</h4><ul><li>方便解耦，简化开发<br>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</li><li>AOP编程的支持<br>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</li><li>声明式事务的支持<br>只需要通过配置就可以完成对事务的管理，而无须手动编程。</li><li>方便程序的测试<br>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</li><li>方便集成各种优秀的框架<br>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架(如：Struts2、Hibernate、MyBatis、Quartz等)的直接支持。</li><li>降低JavaEE API的使用难度<br>Spring对JavaEE开发中非常难用的一些API(JDBC、JavaMail、远程调用等)，都提供了封装，使这些API应用难度大大降低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Spring&quot;&gt;&lt;a href=&quot;#什么是Spring&quot; class=&quot;headerlink&quot; title=&quot;什么是Spring&quot;&gt;&lt;/a&gt;什么是Spring&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Spring是一个开源框架，Spring是于2003年兴起
      
    
    </summary>
    
      <category term="Spring" scheme="https://blog.john-qh.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://blog.john-qh.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>java 知识点</title>
    <link href="https://blog.john-qh.com/2018/05/04/java-knowledge/"/>
    <id>https://blog.john-qh.com/2018/05/04/java-knowledge/</id>
    <published>2018-05-04T02:37:54.000Z</published>
    <updated>2019-06-21T06:05:19.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整理一些-java-中的常备知识点"><a href="#整理一些-java-中的常备知识点" class="headerlink" title="整理一些 java 中的常备知识点"></a>整理一些 java 中的常备知识点</h3><h4 id="（1）原始数据类型相关知识"><a href="#（1）原始数据类型相关知识" class="headerlink" title="（1）原始数据类型相关知识"></a>（1）原始数据类型相关知识</h4><p>原始数据类型(封装类)：<u>boolean(Integer)，byte(Byte)，short(Short)，char(Character)，int(Integer)，float(Float)，long(Long)，double(Double)</u></p><ul><li><h5 id="boolean-封装类-Boolean"><a href="#boolean-封装类-Boolean" class="headerlink" title="boolean(封装类 Boolean)"></a><em>boolean(封装类 Boolean)</em></h5></li></ul><ol><li>boolean 数据类型非 true 即 false。这个数据类型表示 1 bit，但是它的大小并没有精确定义</li><li>boolean 类型单独使用是4个字节，在数组中又是1个字节</li><li>boolean 不用byte或short，而是使用 int 的原因是：对于32位的CPU来说，一次进行32位的数据交换更加高效</li></ol><p>综上，官方文档对boolean类型没有给出精确的定义，《Java虚拟机规范》给出了“单独时使用4个字节，boolean数组时1个字节”的定义，具体还要看虚拟机实现是否按照规范来，所以1个字节、4个字节都是有可能的。这其实是一种时空权衡。</p><ul><li><h5 id="byte-封装类-Byte"><a href="#byte-封装类-Byte" class="headerlink" title="byte(封装类 Byte)"></a><em>byte(封装类 Byte)</em></h5>byte 使用是 1 个字节, 1 byte = 8 bit</li><li><h5 id="short-封装类-Short"><a href="#short-封装类-Short" class="headerlink" title="short(封装类 Short)"></a><em>short(封装类 Short)</em></h5>short 使用是 2 个字节</li><li><h5 id="char-封装类-Character"><a href="#char-封装类-Character" class="headerlink" title="char(封装类 Character)"></a><em>char(封装类 Character)</em></h5>char 使用是 2 个字节</li><li><h5 id="int-封装类-Integer"><a href="#int-封装类-Integer" class="headerlink" title="int(封装类 Integer)"></a><em>int(封装类 Integer)</em></h5>int 使用是 4 个字节</li><li><h5 id="float-封装类-Float"><a href="#float-封装类-Float" class="headerlink" title="float(封装类 Float)"></a><em>float(封装类 Float)</em></h5>float 单精度浮点数，使用是 4 个字节</li><li><h5 id="long-封装类-Long"><a href="#long-封装类-Long" class="headerlink" title="long(封装类 Long)"></a><em>long(封装类 Long)</em></h5>long 长整型，使用是 8 个字节</li><li><h5 id="double-封装类-Double"><a href="#double-封装类-Double" class="headerlink" title="double(封装类 Double)"></a><em>double(封装类 Double)</em></h5>double 双精度浮点数，使用是 8 个字节</li></ul><h4 id="（2）”-”-与-“equals-”-的区别"><a href="#（2）”-”-与-“equals-”-的区别" class="headerlink" title="（2）”==” 与 “equals()” 的区别"></a>（2）”==” 与 “equals()” 的区别</h4><ol><li>《Thinking in Java》中说：“关系操作符生成的是一个boolean结果，它们计算的是操作数的值之间的关系”。</li><li>“==”判断的是两个对象的内存地址是否一样，适用于原始数据类型和枚举类型（它们的变量存储的是值本身，而引用类型变量存储的是引用）；</li><li>equals是Object类的方法，Object对它的实现是比较内存地址，<strong>我们可以重写这个方法来自定义“相等”这个概念。</strong>比如类库中的String、Date等类就对这个方法进行了重写。</li></ol><p><strong>综上，对于枚举类型和原始数据类型的相等性比较，应该使用”==”；对于引用类型的相等性比较，应该使用equals方法。</strong></p><h4 id="（3）Object中定义了哪些方法？"><a href="#（3）Object中定义了哪些方法？" class="headerlink" title="（3）Object中定义了哪些方法？"></a>（3）Object中定义了哪些方法？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashCode(),clone(),wait(),notify(),notifyAll(),equals(),toString(),finalize(),getClass()</span><br></pre></td></tr></table></figure><h4 id="（4）hashCode的作用？"><a href="#（4）hashCode的作用？" class="headerlink" title="（4）hashCode的作用？"></a>（4）hashCode的作用？</h4><p>在很多地方都会利用到hash表来提高查找效率。在Java的Object类中有一个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。hashCode方法默认返回对象的内存地址</p><p>hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p><ul><li>场景：当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？</li></ul><p>如果用equals方法，需要逐个比较，但是集合数据多的时候就比较耗性能了。</p><p>此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</p><p>java.util.HashMap的中put方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</p><ul><li>equals方法和hashCode方法</li></ul><ol><li>在程序执行期间，<font color="#dd0000">只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</font></li><li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li><li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li></ol><p>在《Java编程思想》一书中的有同第一条类似的一段话：<br>　　“设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码”。</p><h4 id="（5）ArrayList-LinkedList-Vector的区别是什么？"><a href="#（5）ArrayList-LinkedList-Vector的区别是什么？" class="headerlink" title="（5）ArrayList, LinkedList, Vector的区别是什么？"></a>（5）ArrayList, LinkedList, Vector的区别是什么？</h4><ul><li>ArrayList: 内部采用数组存储元素，支持高效随机访问，支持动态调整大小</li><li>LinkedList: 内部采用链表来存储元素，支持快速插入/删除元素，但不支持高效地随机访问</li><li>Vector: 可以看作线程安全版的ArrayList</li></ul><h4 id="（6）String-StringBuilder-StringBuffer的区别是什么？"><a href="#（6）String-StringBuilder-StringBuffer的区别是什么？" class="headerlink" title="（6）String, StringBuilder, StringBuffer的区别是什么？"></a>（6）String, StringBuilder, StringBuffer的区别是什么？</h4><ul><li>String: 不可变的字符序列，若要向其中添加新字符需要创建一个新的String对象</li><li>StringBuilder: 可变字符序列，支持向其中添加新字符（无需创建新对象）</li><li>StringBuffer: 可以看作线程安全版的StringBuilder</li></ul><h4 id="（7）Map-Set-List-Queue-Stack的特点及用法。"><a href="#（7）Map-Set-List-Queue-Stack的特点及用法。" class="headerlink" title="（7）Map, Set, List, Queue, Stack的特点及用法。"></a>（7）Map, Set, List, Queue, Stack的特点及用法。</h4><ul><li>Map&lt;K, V&gt;: Java中存储键值对的数据类型都实现了这个接口，表示“映射表”。支持的两个核心操作是get(Object key)以及put(K key, V value)，分别用来获取键对应的值以及向映射表中插入键值对。</li><li>Set<e>: 实现了这个接口的集合类型中不允许存在重复的元素，代表数学意义上的“集合”。它所支持的核心操作有add(E e),<em> remove(Object o)</em>, contains(Object o)，分别用于添加元素，删除元素以及判断给定元素是否存在于集中。</e></li><li>List<e>: Java中集合框架中的列表类型都实现了这个接口，表示一种有序序列。支持get(int index), add(E e)等操作。</e></li><li>Queue<e>: Java集合框架中的队列接口，代表了“先进先出”队列。支持add(E element), remove()等操作。</e></li><li>Stack<e>: Java集合框架中表示堆栈的数据类型，堆栈是一种“后进先出”的数据结构。支持push(E item), pop()等操作。</e></li></ul><h4 id="（8）HashMap和HashTable的区别"><a href="#（8）HashMap和HashTable的区别" class="headerlink" title="（8）HashMap和HashTable的区别"></a>（8）HashMap和HashTable的区别</h4><ul><li>HashTable是线程安全的，而HashMap不是</li><li>HashMap中允许存在null键和null值，而HashTable中不允许</li></ul><h4 id="（9）HashMap的实现原理"><a href="#（9）HashMap的实现原理" class="headerlink" title="（9）HashMap的实现原理"></a>（9）HashMap的实现原理</h4><p>Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表</p><ul><li>数组的特点：连续空间，寻址迅速，但是在删除或者添加元素的时候需要有较大幅度的移动，所以查询速度快，增删较慢。</li><li>链表正好相反，由于空间不连续，寻址困难，增删元素只需修改指针，所以查询慢、增删快。</li></ul><p>为了查询和增删都快的目的，出现了哈希表。</p><ul><li>哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。HashMap的底层实现是“基于拉链法的散列表”。</li><li><a href="https://blog.csdn.net/tgxblue/article/details/8479147/" target="_blank" rel="noopener">详细分析请参考深入解析HashMap、HashTable</a></li></ul><h4 id="（10）ConcurrentHashMap的实现原理"><a href="#（10）ConcurrentHashMap的实现原理" class="headerlink" title="（10）ConcurrentHashMap的实现原理"></a>（10）ConcurrentHashMap的实现原理</h4><ul><li>ConcurrentHashMap是支持并发读写的HashMap，它的特点是读取数据时无需加锁，写数据时可以保证加锁粒度尽可能的小。由于其内部采用“分段存储”，只需对要进行写操作的数据所在的“段”进行加锁。</li><li><a href="http://www.cnblogs.com/dolphin0520/p/3932905.html" target="_blank" rel="noopener">Java并发编程：并发容器之ConcurrentHashMap</a></li></ul><h4 id="（11）TreeMap-LinkedHashMap-HashMap的区别是什么？"><a href="#（11）TreeMap-LinkedHashMap-HashMap的区别是什么？" class="headerlink" title="（11）TreeMap, LinkedHashMap, HashMap的区别是什么？"></a>（11）TreeMap, LinkedHashMap, HashMap的区别是什么？</h4><ul><li>HashMap的底层实现是散列表，因此它内部存储的元素是无序的；</li><li>TreeMap的底层实现是红黑树，所以它内部的元素的有序的。排序的依据是自然序或者是创建TreeMap时所提供的比较器（Comparator）对象。</li><li>LinkedHashMap可以看作能够记住插入元素的顺序的HashMap。</li></ul><h4 id="（12）Collection与Collections的区别是什么？"><a href="#（12）Collection与Collections的区别是什么？" class="headerlink" title="（12）Collection与Collections的区别是什么？"></a>（12）Collection与Collections的区别是什么？</h4><ul><li>Collection<e>是Java集合框架中的基本接口；</e></li><li>Collections是Java集合框架提供的一个工具类，其中包含了大量用于操作或返回集合的静态方法。</li><li><a href="https://www.cnblogs.com/Eason-S/p/5786066.html" target="_blank" rel="noopener">Collections类常用方法总结</a></li></ul><h4 id="（13）Java中的异常层次结构"><a href="#（13）Java中的异常层次结构" class="headerlink" title="（13）Java中的异常层次结构"></a>（13）Java中的异常层次结构</h4><ul><li>Throwable类是异常层级中的基类。</li><li>Error类表示内部错误，这类错误使我们无法控制的；</li><li>Exception表示异常，RuntimeException及其子类属于未检查异常，这类异常包括ArrayIndexOutOfBoundsException、NullPointerException等，我们应该通过条件判断等方式语句避免未检查异常的发生。</li><li>IOException及其子类属于已检查异常，编译器会检查我们是否为所有可能抛出的已检查异常提供了异常处理器，若没有则会报错。对于未检查异常，我们无需捕获（当然Java也允许我们捕获，但我们应该做的事避免未检查异常的发生）。</li></ul><h4 id="（14）Java面向对象的三个特征与含义"><a href="#（14）Java面向对象的三个特征与含义" class="headerlink" title="（14）Java面向对象的三个特征与含义"></a>（14）Java面向对象的三个特征与含义</h4><ul><li>三大特征：封装、继承、多态。<a href="http://javabc.baike.com/article-692235.html" target="_blank" rel="noopener">详细介绍请戳Java面向对象三大特性</a></li></ul><h4 id="（15）Override-Overload的含义与区别"><a href="#（15）Override-Overload的含义与区别" class="headerlink" title="（15）Override, Overload的含义与区别"></a>（15）Override, Overload的含义与区别</h4><ul><li>Override表示“重写”，是子类对父类中同一方法的重新定义</li><li>Overload表示“重载”，也就是定义一个与已定义方法名称相同但签名不同的新方法</li></ul><h4 id="（16）接口与抽象类的区别"><a href="#（16）接口与抽象类的区别" class="headerlink" title="（16）接口与抽象类的区别"></a>（16）接口与抽象类的区别</h4><ul><li>接口是一种约定，实现接口的类要遵循这个约定；</li><li>抽象类本质上是一个类，使用抽象类的代价要比接口大。<br>接口与抽象类的对比如下：</li></ul><ol><li>抽象类中可以包含属性，方法（包含抽象方法与有着具体实现的方法），常量；接口只能包含常量和方法声明。</li><li>抽象类中的方法和成员变量可以定义可见性（比如public、private等）；而接口中的方法只能为public（缺省为public）。</li><li>一个子类只能有一个父类（具体类或抽象类）；而一个接口可以继承一个或多个接口，一个类也可以实现多个接口。</li><li>子类中实现父类中的抽象方法时，可见性可以大于等于父类中的；而接口实现类中的接口 方法的可见性只能与接口中相同（public）。</li></ol><h4 id="（17）Java中多态的实现原理"><a href="#（17）Java中多态的实现原理" class="headerlink" title="（17）Java中多态的实现原理"></a>（17）Java中多态的实现原理</h4><ul><li>所谓多态，指的就是父类引用指向子类对象，调用方法时会调用子类的实现而不是父类的实现。多态的实现的关键在于“动态绑定”。</li><li><a href="https://blog.csdn.net/sureyonder/article/details/5569617" target="_blank" rel="noopener">Java动态绑定的内部实现机制</a></li></ul><h4 id="（18）简述Java中创建新线程的两种方法"><a href="#（18）简述Java中创建新线程的两种方法" class="headerlink" title="（18）简述Java中创建新线程的两种方法"></a>（18）简述Java中创建新线程的两种方法</h4><ol><li><h5 id="继承Thread类。"><a href="#继承Thread类。" class="headerlink" title="继承Thread类。"></a>继承Thread类。</h5><h6 id="1）定义Thread类的子类，并重写该类的run-方法，该方法的方法体就是线程需要完成的任务，run-方法也称为线程执行体。"><a href="#1）定义Thread类的子类，并重写该类的run-方法，该方法的方法体就是线程需要完成的任务，run-方法也称为线程执行体。" class="headerlink" title="1）定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。"></a>1）定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</h6><h6 id="2）创建Thread子类的实例，也就是创建了线程对象"><a href="#2）创建Thread子类的实例，也就是创建了线程对象" class="headerlink" title="2）创建Thread子类的实例，也就是创建了线程对象"></a>2）创建Thread子类的实例，也就是创建了线程对象</h6><h6 id="3）启动线程，即调用线程的start-方法"><a href="#3）启动线程，即调用线程的start-方法" class="headerlink" title="3）启动线程，即调用线程的start()方法"></a>3）启动线程，即调用线程的start()方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　　<span class="keyword">new</span> MyThread().start();<span class="comment">//创建并启动线程</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="实现Runnable接口。"><a href="#实现Runnable接口。" class="headerlink" title="实现Runnable接口。"></a>实现Runnable接口。</h5><h6 id="1）定义Runnable接口的实现类，一样要重写run-方法，这个run（）方法和Thread中的run-方法一样是线程的执行体。"><a href="#1）定义Runnable接口的实现类，一样要重写run-方法，这个run（）方法和Thread中的run-方法一样是线程的执行体。" class="headerlink" title="1）定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体。"></a>1）定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体。</h6><h6 id="2）创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象。"><a href="#2）创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象。" class="headerlink" title="2）创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象。"></a>2）创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象。</h6><h6 id="3）第三部依然是通过调用线程对象的start-方法来启动线程。"><a href="#3）第三部依然是通过调用线程对象的start-方法来启动线程。" class="headerlink" title="3）第三部依然是通过调用线程对象的start()方法来启动线程。"></a>3）第三部依然是通过调用线程对象的start()方法来启动线程。</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> MyThread2();</span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myThread);</span><br><span class="line">　　　　thread().start();</span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="使用Callable和Future创建线程。"><a href="#使用Callable和Future创建线程。" class="headerlink" title="使用Callable和Future创建线程。"></a>使用Callable和Future创建线程。</h5></li></ol><p>和Runnable接口不一样，Callable接口提供了一个call()方法作为线程执行体，call()方法比run()方法功能要强大。</p><h6 id="gt-gt-call-方法可以有返回值"><a href="#gt-gt-call-方法可以有返回值" class="headerlink" title="&gt;&gt;call()方法可以有返回值"></a>&gt;&gt;call()方法可以有返回值</h6><h6 id="gt-gt-call-方法可以声明抛出异常"><a href="#gt-gt-call-方法可以声明抛出异常" class="headerlink" title="&gt;&gt;call()方法可以声明抛出异常"></a>&gt;&gt;call()方法可以声明抛出异常</h6><p>在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p><h6 id="gt-gt-boolean-cancel-boolean-mayInterruptIfRunning-：视图取消该Future里面关联的Callable任务"><a href="#gt-gt-boolean-cancel-boolean-mayInterruptIfRunning-：视图取消该Future里面关联的Callable任务" class="headerlink" title="&gt;&gt;boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务"></a>&gt;&gt;boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</h6><h6 id="gt-gt-V-get-：返回Callable里call-方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值"><a href="#gt-gt-V-get-：返回Callable里call-方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值" class="headerlink" title="&gt;&gt;V get()：返回Callable里call()方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值"></a>&gt;&gt;V get()：返回Callable里call()方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</h6><h6 id="gt-gt-V-get-long-timeout-TimeUnit-unit-：返回Callable里call-方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException"><a href="#gt-gt-V-get-long-timeout-TimeUnit-unit-：返回Callable里call-方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException" class="headerlink" title="&gt;&gt;V get(long timeout,TimeUnit unit)：返回Callable里call()方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException"></a>&gt;&gt;V get(long timeout,TimeUnit unit)：返回Callable里call()方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</h6><h6 id="gt-gt-boolean-isDone-：若Callable任务完成，返回True"><a href="#gt-gt-boolean-isDone-：若Callable任务完成，返回True" class="headerlink" title="&gt;&gt;boolean isDone()：若Callable任务完成，返回True"></a>&gt;&gt;boolean isDone()：若Callable任务完成，返回True</h6><h6 id="gt-gt-boolean-isCancelled-：如果在Callable任务正常完成前被取消，返回True"><a href="#gt-gt-boolean-isCancelled-：如果在Callable任务正常完成前被取消，返回True" class="headerlink" title="&gt;&gt;boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True"></a>&gt;&gt;boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</h6><p>具体操作步骤：<a href="https://blog.csdn.net/ghsau/article/details/7451464" target="_blank" rel="noopener">Callable和Future</a></p><h5 id="一般推荐采用实现接口的方式来创建多线程"><a href="#一般推荐采用实现接口的方式来创建多线程" class="headerlink" title="一般推荐采用实现接口的方式来创建多线程"></a>一般推荐采用实现接口的方式来创建多线程</h5><h4 id="Java线程专栏文章汇总"><a href="#Java线程专栏文章汇总" class="headerlink" title="Java线程专栏文章汇总"></a><a href="https://blog.csdn.net/ghsau/article/details/17609747" target="_blank" rel="noopener">Java线程专栏文章汇总</a></h4><h4 id="（19）单例"><a href="#（19）单例" class="headerlink" title="（19）单例"></a>（19）单例</h4><h5 id="1，懒汉式"><a href="#1，懒汉式" class="headerlink" title="1，懒汉式"></a>1，懒汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1，饿汉式"><a href="#1，饿汉式" class="headerlink" title="1，饿汉式"></a>1，饿汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> class <span class="title">SingleHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single2 instance = <span class="keyword">new</span> Single2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Single2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleHandle.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（20）排序算法"><a href="#（20）排序算法" class="headerlink" title="（20）排序算法"></a>（20）排序算法</h4><h5 id="1-冒泡"><a href="#1-冒泡" class="headerlink" title="1 冒泡"></a>1 冒泡</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length-<span class="number">1</span>-i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-选择"><a href="#2-选择" class="headerlink" title="2 选择"></a>2 选择</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[index] &gt; array[j]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index!=i)&#123; <span class="comment">//找到了比array[i]小的则与array[i]交换位置</span></span><br><span class="line">            t = array[i];</span><br><span class="line">            array[i] = array[index];</span><br><span class="line">            array[index] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-插入"><a href="#3-插入" class="headerlink" title="3 插入"></a>3 插入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        t = array[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; t &lt; array[j]; j--) &#123;</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;整理一些-java-中的常备知识点&quot;&gt;&lt;a href=&quot;#整理一些-java-中的常备知识点&quot; class=&quot;headerlink&quot; title=&quot;整理一些 java 中的常备知识点&quot;&gt;&lt;/a&gt;整理一些 java 中的常备知识点&lt;/h3&gt;&lt;h4 id=&quot;（1）原始
      
    
    </summary>
    
      <category term="java" scheme="https://blog.john-qh.com/categories/java/"/>
    
    
      <category term="java" scheme="https://blog.john-qh.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java源代码赏析 —— String类</title>
    <link href="https://blog.john-qh.com/2018/05/03/java-String/"/>
    <id>https://blog.john-qh.com/2018/05/03/java-String/</id>
    <published>2018-05-03T05:17:21.000Z</published>
    <updated>2019-06-21T06:05:19.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-String类声明"><a href="#1-String类声明" class="headerlink" title="(1) String类声明"></a>(1) String类声明</h4><h5 id="String类实现了序列化、比较器两个接口，用final修饰符说明该类不能被其他类继承，其他类不能重写该类已有的方法"><a href="#String类实现了序列化、比较器两个接口，用final修饰符说明该类不能被其他类继承，其他类不能重写该类已有的方法" class="headerlink" title="String类实现了序列化、比较器两个接口，用final修饰符说明该类不能被其他类继承，其他类不能重写该类已有的方法"></a>String类实现了序列化、比较器两个接口，用final修饰符说明该类不能被其他类继承，其他类不能重写该类已有的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang; <span class="comment">//定义在java.lang包下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequece</span></span></span><br></pre></td></tr></table></figure><h4 id="2-字符串的本质是-char"><a href="#2-字符串的本质是-char" class="headerlink" title="(2) 字符串的本质是 char[]"></a>(2) 字符串的本质是 char[]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span> <span class="comment">//该数组用于字符存储</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]; <span class="comment">//String 类底层是 char 数组</span></span><br></pre></td></tr></table></figure><h4 id="3-String-类的无参构造方法"><a href="#3-String-类的无参构造方法" class="headerlink" title="(3) String 类的无参构造方法"></a>(3) String 类的无参构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>]; <span class="comment">//构造一个空串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-String-类的其他参构造方法"><a href="#4-String-类的其他参构造方法" class="headerlink" title="(4) String 类的其他参构造方法"></a>(4) String 类的其他参构造方法</h4><h5 id="4-1-String类型"><a href="#4-1-String类型" class="headerlink" title="4.1 String类型"></a>4.1 String类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = original.value;</span><br><span class="line">  <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-使用-char-构造一个字符串"><a href="#4-2-使用-char-构造一个字符串" class="headerlink" title="4.2 使用 char[] 构造一个字符串"></a>4.2 使用 char[] 构造一个字符串</h5><h6 id="调用-Arrays-类字符串拷贝函数复制一份字符完成构造"><a href="#调用-Arrays-类字符串拷贝函数复制一份字符完成构造" class="headerlink" title="调用 Arrays 类字符串拷贝函数复制一份字符完成构造"></a>调用 Arrays 类字符串拷贝函数复制一份字符完成构造</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(Char value[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(Char value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//处理非法参数</span></span><br><span class="line">  <span class="keyword">if</span>(offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">  <span class="keyword">if</span>(offset &gt; value.length - count) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//参数合法，调用字符串复制函数复制目标char[]到value[]</span></span><br><span class="line">  <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-int-构造一个字符串"><a href="#4-3-int-构造一个字符串" class="headerlink" title="4.3 int[] 构造一个字符串"></a>4.3 int[] 构造一个字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">  <span class="keyword">if</span> (offset &gt; codePoints.length - count) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> end = offset + count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass 1: Compute precise size of char[]</span></span><br><span class="line">  <span class="keyword">int</span> n = count;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">    <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Character.isValidCodePoint(c))</span><br><span class="line">      n++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Integer.toString(c));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass 2: Allocate and fill in char[]</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">char</span>[] v = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = offset, j = <span class="number">0</span>; i &lt; end; i++, j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">    <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">      v[j] = (<span class="keyword">char</span>)c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      Character.toSurrogates(c, v, j++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-bytes-构造一个字符串"><a href="#4-4-bytes-构造一个字符串" class="headerlink" title="4.4 bytes[] 构造一个字符串"></a>4.4 bytes[] 构造一个字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//offset 是起始位置，length是从起始位置计要构造字符串的长度</span></span><br><span class="line">  checkBounds(bytes, offset, length);</span><br><span class="line">  <span class="keyword">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">  checkBounds(bytes, offset, length);</span><br><span class="line">  <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">  checkBounds(bytes, offset, length);</span><br><span class="line">  <span class="keyword">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charsetName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-5-StringBuffer（线程安全）-构造一个字符串"><a href="#4-5-StringBuffer（线程安全）-构造一个字符串" class="headerlink" title="4.5 StringBuffer（线程安全） 构造一个字符串"></a>4.5 StringBuffer（线程安全） 构造一个字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-6-StringBuilder（线程不安全）-构造一个字符串"><a href="#4-6-StringBuilder（线程不安全）-构造一个字符串" class="headerlink" title="4.6 StringBuilder（线程不安全） 构造一个字符串"></a>4.6 StringBuilder（线程不安全） 构造一个字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-检查边界的函数"><a href="#5-检查边界的函数" class="headerlink" title="(5) 检查边界的函数"></a>(5) 检查边界的函数</h4><h5 id="如果越界会抛出异常-StringIndexOutOfBoundsException"><a href="#如果越界会抛出异常-StringIndexOutOfBoundsException" class="headerlink" title="如果越界会抛出异常 StringIndexOutOfBoundsException"></a>如果越界会抛出异常 StringIndexOutOfBoundsException</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">byte</span>[] bytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">if</span>(offset &gt; bytes.length - length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-获取字符串的长度"><a href="#6-获取字符串的长度" class="headerlink" title="(6) 获取字符串的长度"></a>(6) 获取字符串的长度</h4><h5 id="字符串的长度也就是value数组的长度，即有效字的个数。"><a href="#字符串的长度也就是value数组的长度，即有效字的个数。" class="headerlink" title="字符串的长度也就是value数组的长度，即有效字的个数。"></a>字符串的长度也就是value数组的长度，即有效字的个数。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-判断字符串是否是空串"><a href="#7-判断字符串是否是空串" class="headerlink" title="(7) 判断字符串是否是空串"></a>(7) 判断字符串是否是空串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value.length == <span class="number">0</span>; <span class="comment">//判断其有效字符个数是否为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-获取某一位置的字符"><a href="#8-获取某一位置的字符" class="headerlink" title="(8) 获取某一位置的字符"></a>(8) 获取某一位置的字符</h4><h5 id="如果传入的索引合法，就返回该位置的字符"><a href="#如果传入的索引合法，就返回该位置的字符" class="headerlink" title="如果传入的索引合法，就返回该位置的字符"></a>如果传入的索引合法，就返回该位置的字符</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-获取某一位置的字符对应的-int-值"><a href="#9-获取某一位置的字符对应的-int-值" class="headerlink" title="(9) 获取某一位置的字符对应的 int 值"></a>(9) 获取某一位置的字符对应的 int 值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Character.codePointAtImpl(value, index, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-将字符串转换为-byte-数组"><a href="#10-将字符串转换为-byte-数组" class="headerlink" title="(10) 将字符串转换为 byte[] 数组"></a>(10) 将字符串转换为 byte[] 数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">  <span class="keyword">return</span> StringCoding.encode(value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-重要-字符串比较函数-equals"><a href="#11-重要-字符串比较函数-equals" class="headerlink" title="(11)  (重要)  字符串比较函数 equals()"></a>(11) <font color="#dd0000"> (重要) </font> 字符串比较函数 equals()</h4><h5 id="不同于-“-”-比较，该函数比较的是字符串的内容而非引用，前者比较的是引用（地址）"><a href="#不同于-“-”-比较，该函数比较的是字符串的内容而非引用，前者比较的是引用（地址）" class="headerlink" title="不同于 “==” 比较，该函数比较的是字符串的内容而非引用，前者比较的是引用（地址）"></a>不同于 “==” 比较，该函数比较的是字符串的内容而非引用，前者比较的是引用（地址）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123; <span class="comment">//使用Object类接收，向上转型</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> String) &#123; <span class="comment">//确定是否是String类的对象</span></span><br><span class="line">    String anotherString = (String)anObject;<span class="comment">//强制转换为String</span></span><br><span class="line">    <span class="keyword">int</span> n = value.length;</span><br><span class="line">    <span class="comment">//先比较长度,再比较内容</span></span><br><span class="line">    <span class="keyword">if</span>(n == anotherString.value.length) &#123;</span><br><span class="line">      <span class="keyword">char</span> v1[] = value;</span><br><span class="line">      <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(n-- != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v1[i] != v2[i]) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//不是String类型，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-比较两个字符串内容，忽略大小写"><a href="#12-比较两个字符串内容，忽略大小写" class="headerlink" title="(12) 比较两个字符串内容，忽略大小写"></a>(12) 比较两个字符串内容，忽略大小写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span> : (anotherString != <span class="keyword">null</span>)</span><br><span class="line">          &amp;&amp; (anotherString.value.length == value.length)</span><br><span class="line">          &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ta[] = value;</span><br><span class="line">  <span class="keyword">int</span> to = toffset;</span><br><span class="line">  <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">  <span class="keyword">int</span> po = ooffset;</span><br><span class="line">  <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">  <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">        || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">        || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">    <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">    <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ignoreCase) &#123;</span><br><span class="line">      <span class="comment">// If characters don't match but case may be ignored,</span></span><br><span class="line">      <span class="comment">// try converting both characters to uppercase.</span></span><br><span class="line">      <span class="comment">// If the results match, then the comparison scan should</span></span><br><span class="line">      <span class="comment">// continue.</span></span><br><span class="line">      <span class="comment">// 先转大写进行比较</span></span><br><span class="line">      <span class="keyword">char</span> u1 = Character.toUpperCase(c1);</span><br><span class="line">      <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">      <span class="keyword">if</span> (u1 == u2) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class="line">      <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class="line">      <span class="comment">// conversion.  So we need to make one last check before</span></span><br><span class="line">      <span class="comment">// exiting.</span></span><br><span class="line">      <span class="comment">// 如果转大写比较不成功（由于某种原因），转小写再进行比较一次</span></span><br><span class="line">      <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-判断该字符串是否以某个指定字符串开头"><a href="#13-判断该字符串是否以某个指定字符串开头" class="headerlink" title="(13) 判断该字符串是否以某个指定字符串开头"></a>(13) 判断该字符串是否以某个指定字符串开头</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ta[] = value;</span><br><span class="line">  <span class="keyword">int</span> to = toffset;</span><br><span class="line">  <span class="keyword">char</span> pa[] = prefix.value;</span><br><span class="line">  <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">  <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">  <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> startsWith(prefix, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-判断该字符串是否以某个指定字符串结尾"><a href="#14-判断该字符串是否以某个指定字符串结尾" class="headerlink" title="(14) 判断该字符串是否以某个指定字符串结尾"></a>(14) 判断该字符串是否以某个指定字符串结尾</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-hashCode-生成规则"><a href="#15-hashCode-生成规则" class="headerlink" title="(15) hashCode 生成规则"></a>(15) hashCode 生成规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h = hash;</span><br><span class="line">  <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;<span class="comment">// 没有生成过的时候才进入</span></span><br><span class="line">    <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    hash = h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-查找字符串的位置"><a href="#16-查找字符串的位置" class="headerlink" title="(16) 查找字符串的位置"></a>(16) 查找字符串的位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> indexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">          str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//source 原值， target 查找目标值， offset 起始位置， count 字符串长度 </span></span><br><span class="line">  <span class="comment">//fromIndex 开始查找的位置</span></span><br><span class="line">  <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">    <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    fromIndex = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fromIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> first = target[targetOffset];</span><br><span class="line">  <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">    <span class="comment">/* Look for first character. */</span></span><br><span class="line">    <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">      <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">              == target[k]; j++, k++);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">        <span class="comment">/* Found whole string. */</span></span><br><span class="line">        <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17-查找字符串的最后位置"><a href="#17-查找字符串的最后位置" class="headerlink" title="(17) 查找字符串的最后位置"></a>(17) 查找字符串的最后位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lastIndexOf(str, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lastIndexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">          str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Check arguments; return immediately where possible. For</span></span><br><span class="line"><span class="comment">    * consistency, don't check for null str.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">int</span> rightIndex = sourceCount - targetCount;</span><br><span class="line">  <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fromIndex &gt; rightIndex) &#123;</span><br><span class="line">      fromIndex = rightIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Empty string always matches. */</span></span><br><span class="line">  <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fromIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> strLastChar = target[strLastIndex];</span><br><span class="line">  <span class="keyword">int</span> min = sourceOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> i = min + fromIndex;</span><br><span class="line"></span><br><span class="line">startSearchForLastChar:</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; min) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = j - (targetCount - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k = strLastIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &gt; start) &#123;</span><br><span class="line">      <span class="keyword">if</span> (source[j--] != target[k--]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">continue</span> startSearchForLastChar;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start - sourceOffset + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-截取子串"><a href="#18-截取子串" class="headerlink" title="(18) 截取子串"></a>(18) 截取子串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">  <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">  <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">      : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="19-字符串连接"><a href="#19-字符串连接" class="headerlink" title="(19) 字符串连接"></a>(19) 字符串连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">  <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> len = value.length;</span><br><span class="line">  <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">  str.getChars(buf, len);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">  System.arraycopy(value, <span class="number">0</span>, dst, dstBegin, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">  <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20-替换全部"><a href="#20-替换全部" class="headerlink" title="(20) 替换全部"></a>(20) 替换全部</h4><h5 id="替换原字符串中符合要求的所有片段"><a href="#替换原字符串中符合要求的所有片段" class="headerlink" title="替换原字符串中符合要求的所有片段"></a>替换原字符串中符合要求的所有片段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">      <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        buf[j] = val[j];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = val[i];</span><br><span class="line">        buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21-是否匹配该正则表达式"><a href="#21-是否匹配该正则表达式" class="headerlink" title="(21) 是否匹配该正则表达式"></a>(21) 是否匹配该正则表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="22-是否包含该字符"><a href="#22-是否包含该字符" class="headerlink" title="(22) 是否包含该字符"></a>(22) 是否包含该字符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> indexOf(s.toString()) &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="23-字符串拆分"><a href="#23-字符串拆分" class="headerlink" title="(23) 字符串拆分"></a>(23) 字符串拆分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex) &#123;</span><br><span class="line">  <span class="keyword">return</span> split(regex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">  <span class="comment">/* fastpath if the regex is a</span></span><br><span class="line"><span class="comment">    (1)one-char String and this character is not one of the</span></span><br><span class="line"><span class="comment">      RegEx's meta characters ".$|()[&#123;^?*+\\", or</span></span><br><span class="line"><span class="comment">    (2)two-char String and the first char is the backslash and</span></span><br><span class="line"><span class="comment">      the second is not the ascii digit or ascii letter.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">        (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">        regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">        (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">      (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">        ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">      ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">              list.add(substring(off, next));</span><br><span class="line">              off = next + <span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">              <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">              list.add(substring(off, value.length));</span><br><span class="line">              off = value.length;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If no match was found, return this</span></span><br><span class="line">      <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add remaining segment</span></span><br><span class="line">      <span class="keyword">if</span> (!limited || list.size() &lt; limit)</span><br><span class="line">          list.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Construct result</span></span><br><span class="line">      <span class="keyword">int</span> resultSize = list.size();</span><br><span class="line">      <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">              resultSize--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">      <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24-去除两端空格"><a href="#24-去除两端空格" class="headerlink" title="(24) 去除两端空格"></a>(24) 去除两端空格</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = value.length;</span><br><span class="line">  <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">    st++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">    len--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="25-toString-方法"><a href="#25-toString-方法" class="headerlink" title="(25) toString 方法"></a>(25) toString 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-String类声明&quot;&gt;&lt;a href=&quot;#1-String类声明&quot; class=&quot;headerlink&quot; title=&quot;(1) String类声明&quot;&gt;&lt;/a&gt;(1) String类声明&lt;/h4&gt;&lt;h5 id=&quot;String类实现了序列化、比较器两个接口，用fi
      
    
    </summary>
    
      <category term="java" scheme="https://blog.john-qh.com/categories/java/"/>
    
    
      <category term="java 源码" scheme="https://blog.john-qh.com/tags/java-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>java源代码赏析 —— Object类</title>
    <link href="https://blog.john-qh.com/2018/05/02/java-Object/"/>
    <id>https://blog.john-qh.com/2018/05/02/java-Object/</id>
    <published>2018-05-02T05:10:56.000Z</published>
    <updated>2019-06-21T06:34:06.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object类-——-一切类的父类"><a href="#Object类-——-一切类的父类" class="headerlink" title="Object类 —— 一切类的父类"></a>Object类 —— 一切类的父类</h3><h4 id="1-Object类的声明"><a href="#1-Object类的声明" class="headerlink" title="(1) Object类的声明"></a>(1) Object类的声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang; <span class="comment">//Object 类定义在java.lang 包下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h4 id="2-registerNatives-方法"><a href="#2-registerNatives-方法" class="headerlink" title="(2) registerNatives 方法"></a>(2) registerNatives 方法</h4><h5 id="通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。例如，对于java-lang-Object-registerNatives，对应的C函数命名为Java-java-lang-Object-registerNatives。通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。"><a href="#通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。例如，对于java-lang-Object-registerNatives，对应的C函数命名为Java-java-lang-Object-registerNatives。通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。" class="headerlink" title="通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。"></a>通常情况下，为了使JVM发现您的本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），您可以命名任何你想要你的C函数。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-hashCode-方法"><a href="#3-hashCode-方法" class="headerlink" title="(3) hashCode 方法"></a>(3) hashCode 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="4-重要-equals-方法-——-比较对象的引用"><a href="#4-重要-equals-方法-——-比较对象的引用" class="headerlink" title="(4)  (重要)  equals() 方法 —— 比较对象的引用"></a>(4) <font color="#dd0000"> (重要) </font> equals() 方法 —— 比较对象的引用</h4><h5 id="Object类的equals-方法比较的是对象的引用而不是内容，这与实际生活的情况不符，实际生活中人们要求比较的是内容-比较引用没有意义，所以其他类继承Object类之后-往往需要重写equals-方法"><a href="#Object类的equals-方法比较的是对象的引用而不是内容，这与实际生活的情况不符，实际生活中人们要求比较的是内容-比较引用没有意义，所以其他类继承Object类之后-往往需要重写equals-方法" class="headerlink" title="Object类的equals()方法比较的是对象的引用而不是内容，这与实际生活的情况不符，实际生活中人们要求比较的是内容,比较引用没有意义，所以其他类继承Object类之后,往往需要重写equals()方法"></a><u>Object类的equals()方法比较的是对象的引用而不是内容</u>，这与实际生活的情况不符，实际生活中人们要求比较的是内容,比较引用没有意义，所以<u>其他类继承Object类之后,往往需要重写equals()方法</u></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-重要-toString-方法-——-打印对象的信息"><a href="#5-重要-toString-方法-——-打印对象的信息" class="headerlink" title="(5)  (重要)  toString() 方法 —— 打印对象的信息"></a>(5) <font color="#dd0000"> (重要) </font> toString() 方法 —— 打印对象的信息</h4><h5 id="打印一个对象就是调用toString-方法，该方法打印这个对象的信息，其他类在继承Object类后，一般要重写此方法，设置打印关于对象的信息的操作。"><a href="#打印一个对象就是调用toString-方法，该方法打印这个对象的信息，其他类在继承Object类后，一般要重写此方法，设置打印关于对象的信息的操作。" class="headerlink" title="打印一个对象就是调用toString()方法，该方法打印这个对象的信息，其他类在继承Object类后，一般要重写此方法，设置打印关于对象的信息的操作。"></a><u>打印一个对象就是调用toString()方法</u>，该方法打印这个对象的信息，<u>其他类在继承Object类后，一般要重写此方法</u>，设置打印关于对象的信息的操作。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName()+<span class="string">"@"</span>+Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-线程的等待"><a href="#6-线程的等待" class="headerlink" title="(6) 线程的等待"></a>(6) 线程的等待</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h5 id="还可以指定等待的最长毫秒和纳秒"><a href="#还可以指定等待的最长毫秒和纳秒" class="headerlink" title="还可以指定等待的最长毫秒和纳秒"></a>还可以指定等待的最长毫秒和纳秒</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">    timeout++;</span><br><span class="line">  &#125;</span><br><span class="line">  wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-唤醒等待的线程"><a href="#7-唤醒等待的线程" class="headerlink" title="(7) 唤醒等待的线程"></a>(7) 唤醒等待的线程</h4><h5 id="7-1-唤醒一个线程"><a href="#7-1-唤醒一个线程" class="headerlink" title="7.1 唤醒一个线程"></a>7.1 唤醒一个线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="7-2-唤醒全部线程"><a href="#7-2-唤醒全部线程" class="headerlink" title="7.2 唤醒全部线程"></a>7.2 唤醒全部线程</h5><h6 id="唤醒全部线程，哪个线程的优先级高，他就有可能先执行"><a href="#唤醒全部线程，哪个线程的优先级高，他就有可能先执行" class="headerlink" title="唤醒全部线程，哪个线程的优先级高，他就有可能先执行"></a>唤醒全部线程，哪个线程的优先级高，他就有可能先执行</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-finalize-方法-——-对象的回收"><a href="#8-finalize-方法-——-对象的回收" class="headerlink" title="(8) finalize() 方法 —— 对象的回收"></a>(8) finalize() 方法 —— 对象的回收</h4><h5 id="当确定一个对象不会被其他方法再使用时，该对象就没有存在的意义了，就只能等待JVM的垃圾回收线程来回收了。垃圾回收是以占用一定内存为代价的。System-gc-就是启动垃圾回收线程的语句。当用户认为需要回收时，可以使用Runtime-getRuntime-gc-或者System-gc-来回收内存。（System-gc-调用的就是Runtime类的-gc-方法）"><a href="#当确定一个对象不会被其他方法再使用时，该对象就没有存在的意义了，就只能等待JVM的垃圾回收线程来回收了。垃圾回收是以占用一定内存为代价的。System-gc-就是启动垃圾回收线程的语句。当用户认为需要回收时，可以使用Runtime-getRuntime-gc-或者System-gc-来回收内存。（System-gc-调用的就是Runtime类的-gc-方法）" class="headerlink" title="当确定一个对象不会被其他方法再使用时，该对象就没有存在的意义了，就只能等待JVM的垃圾回收线程来回收了。垃圾回收是以占用一定内存为代价的。System.gc();就是启动垃圾回收线程的语句。当用户认为需要回收时，可以使用Runtime.getRuntime().gc();或者System.gc();来回收内存。（System.gc();调用的就是Runtime类的 gc()方法）"></a>当确定一个对象不会被其他方法再使用时，该对象就没有存在的意义了，就只能等待JVM的垃圾回收线程来回收了。垃圾回收是以占用一定内存为代价的。System.gc();就是启动垃圾回收线程的语句。当用户认为需要回收时，可以使用Runtime.getRuntime().gc();或者System.gc();来回收内存。（System.gc();调用的就是Runtime类的 gc()方法）</h5><h5 id="当一个对象在回收前想要执行一些操作，就要覆写Object类中的finalize-方法。"><a href="#当一个对象在回收前想要执行一些操作，就要覆写Object类中的finalize-方法。" class="headerlink" title="当一个对象在回收前想要执行一些操作，就要覆写Object类中的finalize()方法。"></a>当一个对象在回收前想要执行一些操作，就要覆写Object类中的finalize()方法。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="注意到抛出的是Throwable，说明除了常规的异常Exception外，还有可能是JVM错误。说明调用该方法不一定只会在程序中产生异常，还有可能产生JVM错误。"><a href="#注意到抛出的是Throwable，说明除了常规的异常Exception外，还有可能是JVM错误。说明调用该方法不一定只会在程序中产生异常，还有可能产生JVM错误。" class="headerlink" title="注意到抛出的是Throwable，说明除了常规的异常Exception外，还有可能是JVM错误。说明调用该方法不一定只会在程序中产生异常，还有可能产生JVM错误。"></a>注意到抛出的是Throwable，说明除了常规的异常Exception外，还有可能是JVM错误。说明调用该方法不一定只会在程序中产生异常，还有可能产生JVM错误。</h5><h4 id="（9）clone-方法-——-用于对象克隆"><a href="#（9）clone-方法-——-用于对象克隆" class="headerlink" title="（9）clone()方法 —— 用于对象克隆"></a>（9）clone()方法 —— 用于对象克隆</h4><h5 id="Object类的直接或间接子类通过在重写该方法并直接调用本类的该方法完成对象克隆。"><a href="#Object类的直接或间接子类通过在重写该方法并直接调用本类的该方法完成对象克隆。" class="headerlink" title="Object类的直接或间接子类通过在重写该方法并直接调用本类的该方法完成对象克隆。"></a>Object类的直接或间接子类通过在重写该方法并直接调用本类的该方法完成对象克隆。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><h5 id="native-关键字表示调用本机操作系统的函数。"><a href="#native-关键字表示调用本机操作系统的函数。" class="headerlink" title="native 关键字表示调用本机操作系统的函数。"></a>native 关键字表示调用本机操作系统的函数。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Object类-——-一切类的父类&quot;&gt;&lt;a href=&quot;#Object类-——-一切类的父类&quot; class=&quot;headerlink&quot; title=&quot;Object类 —— 一切类的父类&quot;&gt;&lt;/a&gt;Object类 —— 一切类的父类&lt;/h3&gt;&lt;h4 id=&quot;1-Obj
      
    
    </summary>
    
      <category term="java" scheme="https://blog.john-qh.com/categories/java/"/>
    
    
      <category term="java 源码" scheme="https://blog.john-qh.com/tags/java-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
